{"version":3,"file":"static/js/55384.96504331.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/transaction/actions/gasless/providers/engine.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport type { TransactionSerializable } from \"viem\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { Account } from \"../../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../../prepare-transaction.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport {\n  type WaitForReceiptOptions,\n  waitForReceipt,\n} from \"../../wait-for-tx-receipt.js\";\n\n/**\n * @transaction\n */\nexport type EngineOptions = {\n  provider: \"engine\";\n  relayerUrl: string;\n  relayerForwarderAddress: Address;\n  domainName?: string; // default: \"GSNv2 Forwarder\"\n  domainVersion?: string; // default: \"0.0.1\"\n  domainSeparatorVersion?: string; // default: \"1\"\n  experimentalChainlessSupport?: boolean; // default: false\n};\n\ntype SendengineTransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n  serializableTransaction: TransactionSerializable;\n  gasless: EngineOptions;\n};\n\n/**\n * @internal - only exported for testing\n */\nexport async function prepareEngineTransaction({\n  account,\n  serializableTransaction,\n  transaction,\n  gasless,\n}: SendengineTransactionOptions) {\n  const forrwaderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client,\n  });\n\n  const nonce = await readContract({\n    contract: forrwaderContract,\n    method: \"function getNonce(address) view returns (uint256)\",\n    params: [account.address],\n  });\n\n  const [signature, message] = await (async () => {\n    // TODO: handle special case for `approve` -> `permit` transactions\n\n    if (!serializableTransaction.to) {\n      throw new Error(\"engine transactions must have a 'to' address\");\n    }\n    if (!serializableTransaction.gas) {\n      throw new Error(\"engine transactions must have a 'gas' value\");\n    }\n    if (!serializableTransaction.data) {\n      throw new Error(\"engine transactions must have a 'data' value\");\n    }\n    // chainless support!\n    if (gasless.experimentalChainlessSupport) {\n      const message = {\n        from: account.address,\n        to: serializableTransaction.to,\n        value: 0n,\n        gas: serializableTransaction.gas,\n        nonce: nonce,\n        data: serializableTransaction.data,\n        chainid: BigInt(transaction.chain.id),\n      } as const;\n      return [\n        await account.signTypedData({\n          domain: {\n            name: \"GSNv2 Forwarder\",\n            version: \"0.0.1\",\n            verifyingContract: forrwaderContract.address,\n          },\n          message,\n          primaryType: \"ForwardRequest\",\n          types: { ForwardRequest: ChainAwareForwardRequest },\n        }),\n        message,\n      ] as const;\n    }\n    // else non-chainless support\n    const message = {\n      from: account.address,\n      to: serializableTransaction.to,\n      value: 0n,\n      gas: serializableTransaction.gas,\n      nonce: nonce,\n      data: serializableTransaction.data,\n    } as const;\n    return [\n      await account.signTypedData({\n        domain: {\n          name: gasless.domainName ?? \"GSNv2 Forwarder\",\n          version: gasless.domainVersion ?? \"0.0.1\",\n          chainId: transaction.chain.id,\n          verifyingContract: forrwaderContract.address,\n        },\n        message,\n        primaryType: \"ForwardRequest\",\n        types: { ForwardRequest },\n      }),\n      message,\n    ] as const;\n  })();\n  // TODO: handle special case for `approve` -> `permit`\n  const messageType = \"forward\";\n\n  return { message, signature, messageType } as const;\n}\n\nexport const ForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n] as const;\n\nexport const ChainAwareForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n  { name: \"chainid\", type: \"uint256\" },\n] as const;\n\n/**\n * @internal\n */\nexport async function relayEngineTransaction(\n  options: SendengineTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { message, messageType, signature } =\n    await prepareEngineTransaction(options);\n\n  const response = await fetch(options.gasless.relayerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      request: message,\n      type: messageType,\n      signature,\n      forwarderAddress: options.gasless.relayerForwarderAddress,\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to send transaction: ${await response.text()}`);\n  }\n  const json = await response.json();\n  if (!json.result) {\n    throw new Error(`Relay transaction failed: ${json.message}`);\n  }\n  const queueId = json.result.queueId;\n  // poll for transactionHash\n  const timeout = 60000;\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const receipt = await fetchReceipt({ options, queueId });\n    if (receipt) {\n      return {\n        transactionHash: receipt.transactionHash,\n        chain: options.transaction.chain,\n        client: options.transaction.client,\n      };\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(`Failed to find relayed transaction after ${timeout}ms`);\n}\n\nasync function fetchReceipt(args: {\n  options: SendengineTransactionOptions;\n  queueId: string;\n}) {\n  const { options, queueId } = args;\n  const url = options.gasless.relayerUrl.split(\"/relayer/\")[0];\n  const res = await fetch(`${url}/transaction/status/${queueId}`, {\n    method: \"GET\",\n  });\n  const resJson = await res.json();\n  if (!res.ok) {\n    return null;\n  }\n  const result = resJson.result;\n  if (!result) {\n    return null;\n  }\n  switch (result.status) {\n    case \"errored\":\n      throw new Error(\n        `Transaction errored with reason: ${result.errorMessage}`,\n      );\n    case \"cancelled\":\n      throw new Error(\"Transaction execution cancelled.\");\n    case \"mined\": {\n      const receipt = await waitForReceipt({\n        client: options.transaction.client,\n        chain: options.transaction.chain,\n        transactionHash: result.transactionHash,\n      });\n      return receipt;\n    }\n    default: {\n      return null;\n    }\n  }\n}\n"],"names":["ForwardRequest","name","type","ChainAwareForwardRequest","async","relayEngineTransaction","options","message","messageType","signature","_ref","account","serializableTransaction","transaction","gasless","forrwaderContract","getContract","address","relayerForwarderAddress","chain","client","nonce","readContract","contract","method","params","_gasless$domainName","_gasless$domainVersio","to","Error","gas","data","experimentalChainlessSupport","from","value","chainid","BigInt","id","signTypedData","domain","version","verifyingContract","primaryType","types","domainName","domainVersion","chainId","prepareEngineTransaction","response","fetch","relayerUrl","headers","body","stringify","request","forwarderAddress","ok","concat","text","json","result","queueId","endtime","Date","now","receipt","fetchReceipt","transactionHash","Promise","resolve","setTimeout","args","url","split","res","resJson","status","errorMessage","waitForReceipt"],"sourceRoot":""}