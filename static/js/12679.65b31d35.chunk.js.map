{"version":3,"file":"static/js/12679.65b31d35.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/auth/core/create-login-message.ts","../node_modules/thirdweb/src/auth/core/sign-login-payload.ts","../node_modules/thirdweb/src/wallets/in-app/core/authentication/getLoginPath.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/constants.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/oauth.ts","../node_modules/thirdweb/src/wallets/in-app/core/authentication/passkeys.ts","../node_modules/thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/IframeCommunicator.ts","../node_modules/thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/InAppWalletIframeCommunicator.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/abstract-login.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/base-login.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/iframe-auth.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/otp.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/in-app-account.ts","../node_modules/thirdweb/src/wallets/ecosystem/get-ecosystem-partner-permissions.ts","../node_modules/thirdweb/src/rpc/actions/eth_sendRawTransaction.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/web-connector.ts","../node_modules/thirdweb/src/wallets/in-app/core/authentication/siwe.ts"],"sourcesContent":["import type { LoginPayload } from \"./types.js\";\n\n/**\n * Create an EIP-4361 & CAIP-122 compliant message to sign based on the login payload\n * @param payload - The login payload containing the necessary information.\n * @returns The generated login message.\n * @internal\n */\nexport function createLoginMessage(payload: LoginPayload): string {\n  const typeField = \"Ethereum\";\n  const header = `${payload.domain} wants you to sign in with your ${typeField} account:`;\n  let prefix = [header, payload.address].join(\"\\n\");\n  prefix = [prefix, payload.statement].join(\"\\n\\n\");\n  if (payload.statement) {\n    prefix += \"\\n\";\n  }\n\n  const suffixArray = [];\n  if (payload.uri) {\n    const uriField = `URI: ${payload.uri}`;\n    suffixArray.push(uriField);\n  }\n\n  const versionField = `Version: ${payload.version}`;\n  suffixArray.push(versionField);\n\n  if (payload.chain_id) {\n    const chainField = `Chain ID: ${payload.chain_id}` || \"1\";\n    suffixArray.push(chainField);\n  }\n\n  const nonceField = `Nonce: ${payload.nonce}`;\n  suffixArray.push(nonceField);\n\n  const issuedAtField = `Issued At: ${payload.issued_at}`;\n  suffixArray.push(issuedAtField);\n\n  const expiryField = `Expiration Time: ${payload.expiration_time}`;\n  suffixArray.push(expiryField);\n\n  if (payload.invalid_before) {\n    const invalidBeforeField = `Not Before: ${payload.invalid_before}`;\n    suffixArray.push(invalidBeforeField);\n  }\n\n  if (payload.resources) {\n    suffixArray.push(\n      [\"Resources:\", ...payload.resources.map((x) => `- ${x}`)].join(\"\\n\"),\n    );\n  }\n\n  const suffix = suffixArray.join(\"\\n\");\n  return [prefix, suffix].join(\"\\n\");\n}\n","import type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { createLoginMessage } from \"./create-login-message.js\";\nimport type { LoginPayload } from \"./types.js\";\n\n/**\n * @auth\n */\nexport type SignLoginPayloadParams = {\n  payload: LoginPayload;\n  account: Account;\n};\n\n/**\n * Signs the login payload using the provided account.\n * @param options - The options for signing the login payload.\n * @returns An object containing the signature and the payload.\n * @example\n * ```ts\n * import { signLoginPayload } from 'thirdweb/auth';\n *\n * const { signature, payload } = await signLoginPayload({\n *  payload: loginPayload,\n *  account: account,\n * });\n * ```\n * @auth\n */\nexport async function signLoginPayload(options: SignLoginPayloadParams) {\n  const { payload, account } = options;\n  const signature = await account.signMessage({\n    message: createLoginMessage(payload),\n  });\n  return {\n    signature,\n    payload,\n  };\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { type AuthOption, authOptions } from \"../../../../wallets/types.js\";\nimport type { Ecosystem } from \"../../web/types.js\";\n\nconst getLoginOptionRoute = (option: AuthOption | \"wallet\") => {\n  if (!authOptions.includes(option as AuthOption) && option !== \"wallet\") {\n    throw new Error(`Unknown auth option ${option}`);\n  }\n  switch (option) {\n    case \"wallet\":\n      return \"siwe\";\n    default:\n      return option;\n  }\n};\n\nexport const getLoginUrl = ({\n  authOption,\n  client,\n  ecosystem,\n  mode = \"popup\",\n  redirectUrl,\n}: {\n  authOption: AuthOption | \"wallet\";\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  mode?: \"popup\" | \"redirect\" | \"mobile\";\n  redirectUrl?: string;\n}) => {\n  const route = getLoginOptionRoute(authOption);\n  let baseUrl = `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/login/${route}?clientId=${client.clientId}`;\n  if (ecosystem?.partnerId) {\n    baseUrl = `${baseUrl}&ecosystemId=${ecosystem.id}&ecosystemPartnerId=${ecosystem.partnerId}`;\n  } else if (ecosystem) {\n    baseUrl = `${baseUrl}&ecosystemId=${ecosystem.id}`;\n  }\n\n  if (mode === \"redirect\") {\n    const formattedRedirectUrl = new URL(redirectUrl || window.location.href);\n    formattedRedirectUrl.searchParams.set(\"walletId\", ecosystem?.id || \"inApp\");\n    formattedRedirectUrl.searchParams.set(\"authProvider\", authOption);\n    baseUrl = `${baseUrl}&redirectUrl=${encodeURIComponent(formattedRedirectUrl.toString())}`;\n  }\n\n  if (mode === \"mobile\") {\n    if (!redirectUrl) {\n      throw new Error(\"Redirect URL is required for mobile authentication\");\n    }\n    baseUrl = `${baseUrl}&redirectUrl=${encodeURIComponent(redirectUrl)}`;\n  }\n\n  return baseUrl;\n};\n\nexport const getLoginCallbackUrl = ({\n  authOption,\n  client,\n  ecosystem,\n}: {\n  authOption: AuthOption | \"wallet\";\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n}): string => {\n  const route = getLoginOptionRoute(authOption);\n  let baseUrl = `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/login/${route}/callback?clientId=${client.clientId}`;\n  if (ecosystem?.partnerId) {\n    baseUrl = `${baseUrl}&ecosystemId=${ecosystem.id}&ecosystemPartnerId=${ecosystem.partnerId}`;\n  } else if (ecosystem) {\n    baseUrl = `${baseUrl}&ecosystemId=${ecosystem.id}`;\n  }\n\n  return baseUrl;\n};\n","export const DEFAULT_POP_UP_SIZE = \"width=350, height=500\";\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../../utils/domains.js\";\nimport type { SocialAuthOption } from \"../../../../../wallets/types.js\";\nimport { getLoginUrl } from \"../../../core/authentication/getLoginPath.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"../../../core/authentication/types.js\";\nimport type { Ecosystem } from \"../../types.js\";\nimport { DEFAULT_POP_UP_SIZE } from \"./constants.js\";\n\nconst closeWindow = ({\n  isWindowOpenedByFn,\n  win,\n  closeOpenedWindow,\n}: {\n  win?: Window | null;\n  isWindowOpenedByFn: boolean;\n  closeOpenedWindow?: (openedWindow: Window) => void;\n}) => {\n  if (isWindowOpenedByFn) {\n    win?.close();\n  } else {\n    if (win && closeOpenedWindow) {\n      closeOpenedWindow(win);\n    } else if (win) {\n      win.close();\n    }\n  }\n};\n\nexport const loginWithOauthRedirect = (options: {\n  authOption: SocialAuthOption;\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  redirectUrl?: string;\n  redirectExternally?: boolean;\n}): void => {\n  const loginUrl = getLoginUrl({\n    ...options,\n    mode: \"redirect\",\n  });\n  if (options.redirectExternally === true) {\n    window.open(loginUrl);\n  } else {\n    window.location.href = loginUrl;\n  }\n};\n\nexport const loginWithOauth = async (options: {\n  authOption: SocialAuthOption;\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  openedWindow?: Window | null | undefined;\n  closeOpenedWindow?: ((openedWindow: Window) => void) | undefined;\n}): Promise<AuthStoredTokenWithCookieReturnType> => {\n  let win = options.openedWindow;\n  let isWindowOpenedByFn = false;\n  if (!win) {\n    win = window.open(\n      getLoginUrl({ ...options, mode: \"popup\" }),\n      `Login to ${options.authOption}`,\n      DEFAULT_POP_UP_SIZE,\n    );\n    isWindowOpenedByFn = true;\n  }\n  if (!win) {\n    throw new Error(\"Something went wrong opening pop-up\");\n  }\n\n  const result = await new Promise<AuthStoredTokenWithCookieReturnType>(\n    (resolve, reject) => {\n      // detect when the user closes the login window\n      const pollTimer = window.setInterval(async () => {\n        if (win.closed) {\n          clearInterval(pollTimer);\n          window.removeEventListener(\"message\", messageListener);\n          reject(new Error(\"User closed login window\"));\n        }\n      }, 1000);\n\n      const messageListener = async (\n        event: MessageEvent<{\n          eventType: string;\n          authResult?: AuthStoredTokenWithCookieReturnType;\n          errorString?: string;\n        }>,\n      ) => {\n        if (event.origin !== getThirdwebBaseUrl(\"inAppWallet\")) {\n          return;\n        }\n        if (typeof event.data !== \"object\") {\n          reject(new Error(\"Invalid event data\"));\n          return;\n        }\n\n        switch (event.data.eventType) {\n          case \"oauthSuccessResult\": {\n            window.removeEventListener(\"message\", messageListener);\n            clearInterval(pollTimer);\n            closeWindow({\n              isWindowOpenedByFn,\n              win,\n              closeOpenedWindow: options.closeOpenedWindow,\n            });\n            if (event.data.authResult) {\n              resolve(event.data.authResult);\n            }\n            break;\n          }\n          case \"oauthFailureResult\": {\n            window.removeEventListener(\"message\", messageListener);\n            clearInterval(pollTimer);\n            closeWindow({\n              isWindowOpenedByFn,\n              win,\n              closeOpenedWindow: options.closeOpenedWindow,\n            });\n            reject(new Error(event.data.errorString));\n            break;\n          }\n          default: {\n            // no-op, DO NOT THROW HERE\n          }\n        }\n      };\n      window.addEventListener(\"message\", messageListener);\n    },\n  );\n  return result;\n};\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { AsyncStorage } from \"../../../../utils/storage/AsyncStorage.js\";\nimport type { Ecosystem } from \"../../web/types.js\";\nimport { ClientScopedStorage } from \"./client-scoped-storage.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"./types.js\";\n\nfunction getVerificationPath() {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey/callback`;\n}\nfunction getChallengePath(type: \"sign-in\" | \"sign-up\", username?: string) {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey?type=${type}${\n    username ? `&username=${username}` : \"\"\n  }`;\n}\n\nexport type RegisterResult = {\n  authenticatorData: string;\n  credentialId: string;\n  clientData: string;\n  credential: {\n    publicKey: string;\n    algorithm: string;\n  };\n  origin: string;\n};\n\nexport type AuthenticateResult = {\n  credentialId: string;\n  authenticatorData: string;\n  clientData: string;\n  signature: string;\n  origin: string;\n};\n\nexport type RpInfo = { name: string; id: string };\n\nexport interface PasskeyClient {\n  register: (args: {\n    name: string;\n    challenge: string;\n    rp: RpInfo;\n  }) => Promise<RegisterResult>;\n  authenticate: (args: {\n    credentialId: string | undefined;\n    challenge: string;\n    rp: RpInfo;\n  }) => Promise<AuthenticateResult>;\n  isAvailable: () => boolean;\n}\n\nexport async function registerPasskey(options: {\n  client: ThirdwebClient;\n  storage: AsyncStorage;\n  passkeyClient: PasskeyClient;\n  ecosystem?: Ecosystem;\n  username?: string;\n  rp: RpInfo;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const storage = new ClientScopedStorage({\n    storage: options.storage,\n    clientId: options.client.clientId,\n    ecosystemId: options.ecosystem?.id,\n  });\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  const generatedName = options.username ?? generateUsername(options.ecosystem);\n  // 1. request challenge from  server\n  const res = await fetchWithId(getChallengePath(\"sign-up\", generatedName));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n\n  // 2. initiate registration\n  const registration = await options.passkeyClient.register({\n    name: generatedName,\n    challenge,\n    rp: options.rp,\n  });\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  // 3. send the registration object to the server\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    body: JSON.stringify({\n      type: \"sign-up\",\n      authenticatorData: registration.authenticatorData,\n      credentialId: registration.credentialId,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: registration.clientData,\n      username: generatedName,\n      credential: {\n        publicKey: registration.credential.publicKey,\n        algorithm: registration.credential.algorithm,\n      },\n      origin: registration.origin,\n      rpId: options.rp.id,\n    }),\n  });\n  const verifData = await verifRes.json();\n\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(\n      `Error verifying passkey: ${verifData.message ?? \"unknown error\"}`,\n    );\n  }\n  // 4. store the credentialId in local storage\n  await storage.savePasskeyCredentialId(registration.credentialId);\n\n  // 5. returns back the IAW authentication token\n  return verifData;\n}\n\nexport async function loginWithPasskey(options: {\n  client: ThirdwebClient;\n  storage: AsyncStorage;\n  passkeyClient: PasskeyClient;\n  rp: RpInfo;\n  ecosystem?: Ecosystem;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const storage = new ClientScopedStorage({\n    storage: options.storage,\n    clientId: options.client.clientId,\n    ecosystemId: options.ecosystem?.id,\n  });\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  // 1. request challenge from  server/iframe\n  const res = await fetchWithId(getChallengePath(\"sign-in\"));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 1.2. find the user's credentialId in local storage\n  const credentialId = (await storage.getPasskeyCredentialId()) ?? undefined;\n  // 2. initiate login\n  const authentication = await options.passkeyClient.authenticate({\n    credentialId,\n    challenge,\n    rp: options.rp,\n  });\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    body: JSON.stringify({\n      type: \"sign-in\",\n      authenticatorData: authentication.authenticatorData,\n      credentialId: authentication.credentialId,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: authentication.clientData,\n      signature: authentication.signature,\n      origin: authentication.origin,\n      rpId: options.rp.id,\n    }),\n  });\n\n  const verifData = await verifRes.json();\n\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(\n      `Error verifying passkey: ${verifData.message ?? \"unknown error\"}`,\n    );\n  }\n\n  // 5. store the credentialId in local storage\n  await storage.savePasskeyCredentialId(authentication.credentialId);\n\n  // 6. return the auth'd user type\n  return verifData;\n}\n\nfunction generateUsername(ecosystem?: Ecosystem) {\n  return `${ecosystem?.id ?? \"wallet\"}-${new Date().toISOString()}`;\n}\n","type IFrameCommunicatorProps = {\n  link: string;\n  baseUrl: string;\n  iframeId: string;\n  container?: HTMLElement;\n  onIframeInitialize?: () => void;\n};\n\nfunction sleep(seconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\n\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\",\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map<string, boolean>();\n\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator<T extends { [key: string]: any }> {\n  private iframe: HTMLIFrameElement;\n  private POLLING_INTERVAL_SECONDS = 1.4;\n\n  private iframeBaseUrl;\n  /**\n   * @internal\n   */\n  constructor({\n    link,\n    baseUrl,\n    iframeId,\n    container = document.body,\n    onIframeInitialize,\n  }: IFrameCommunicatorProps) {\n    this.iframeBaseUrl = baseUrl;\n\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId) as HTMLIFrameElement | null;\n    const hrefLink = new URL(link);\n\n    // TODO (ew) - bring back version tracking\n    // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n    // if (!sdkVersion) {\n    //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n    // }\n    // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n\n      iframe = document.createElement(\"iframe\");\n      const mergedIframeStyles = {\n        ...iframeBaseStyle,\n      };\n      Object.assign(iframe.style, mergedIframeStyles);\n      iframe.setAttribute(\"id\", iframeId);\n      iframe.setAttribute(\"fetchpriority\", \"high\");\n      container.appendChild(iframe);\n\n      iframe.src = hrefLink.href;\n\n      // iframe.setAttribute(\"data-version\", sdkVersion);\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      const onIframeLoaded = (event: MessageEvent<any>) => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb iFrame not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  protected async onIframeLoadedInitVariables(): Promise<Record<string, any>> {\n    return {};\n  }\n\n  /**\n   * @internal\n   */\n  onIframeLoadHandler(\n    iframe: HTMLIFrameElement,\n    onIframeInitialize?: () => void,\n  ) {\n    return async () => {\n      const channel = new MessageChannel();\n\n      const promise = new Promise((res, rej) => {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        channel.port1.onmessage = (event: any) => {\n          const { data } = event;\n          channel.port1.close();\n          if (!data.success) {\n            rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          res(true);\n        };\n      });\n\n      const INIT_IFRAME_EVENT = \"initIframe\";\n      iframe?.contentWindow?.postMessage(\n        // ? We initialise the iframe with a bunch\n        // of useful information so that we don't have to pass it\n        // through in each of the future call. This would be where we do it.\n        {\n          eventType: INIT_IFRAME_EVENT,\n          data: await this.onIframeLoadedInitVariables(),\n        },\n        this.iframeBaseUrl,\n        [channel.port2],\n      );\n\n      await promise;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async call<ReturnData>({\n    procedureName,\n    params,\n    showIframe = false,\n  }: {\n    procedureName: keyof T;\n    params: T[keyof T];\n    showIframe?: boolean;\n  }) {\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005);\n    }\n\n    const channel = new MessageChannel();\n    const promise = new Promise<ReturnData>((res, rej) => {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      channel.port1.onmessage = async (event: any) => {\n        const { data } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n    });\n\n    this.iframe.contentWindow?.postMessage(\n      { eventType: procedureName, data: params },\n      this.iframeBaseUrl,\n      [channel.port2],\n    );\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   * @internal\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n","import { webLocalStorage } from \"../../../../../utils/storage/webStorage.js\";\nimport { ClientScopedStorage } from \"../../../core/authentication/client-scoped-storage.js\";\nimport { IN_APP_WALLET_PATH } from \"../../../core/constants/settings.js\";\nimport type { Ecosystem } from \"../../types.js\";\nimport { IframeCommunicator } from \"./IframeCommunicator.js\";\n\n/**\n * @internal\n */\nexport class InAppWalletIframeCommunicator<\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  T extends { [key: string]: any },\n> extends IframeCommunicator<T> {\n  clientId: string;\n  ecosystem?: Ecosystem;\n  /**\n   * @internal\n   */\n  constructor({\n    clientId,\n    baseUrl,\n    ecosystem,\n  }: {\n    clientId: string;\n    baseUrl: string;\n    ecosystem?: Ecosystem;\n  }) {\n    super({\n      iframeId: IN_APP_WALLET_IFRAME_ID + (ecosystem?.id || \"\"),\n      link: createInAppWalletIframeLink({\n        clientId,\n        path: IN_APP_WALLET_PATH,\n        ecosystem,\n        baseUrl,\n      }).href,\n      baseUrl,\n      container: document.body,\n    });\n    this.clientId = clientId;\n    this.ecosystem = ecosystem;\n  }\n\n  /**\n   * @internal\n   */\n  override async onIframeLoadedInitVariables() {\n    const localStorage = new ClientScopedStorage({\n      storage: webLocalStorage,\n      clientId: this.clientId,\n      ecosystemId: this.ecosystem?.id,\n    });\n\n    return {\n      authCookie: await localStorage.getAuthCookie(),\n      deviceShareStored: await localStorage.getDeviceShare(),\n      walletUserId: await localStorage.getWalletUserId(),\n      clientId: this.clientId,\n      partnerId: this.ecosystem?.partnerId,\n      ecosystemId: this.ecosystem?.id,\n    };\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\n/**\n * @internal\n */\nexport function createInAppWalletIframeLink({\n  clientId,\n  baseUrl,\n  path,\n  ecosystem,\n  queryParams,\n}: {\n  clientId: string;\n  baseUrl: string;\n  path: string;\n  ecosystem?: Ecosystem;\n  queryParams?: { [key: string]: string | number };\n}) {\n  const inAppWalletUrl = new URL(`${path}`, baseUrl);\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      inAppWalletUrl.searchParams.set(\n        queryKey,\n        queryParams[queryKey]?.toString() || \"\",\n      );\n    }\n  }\n  inAppWalletUrl.searchParams.set(\"clientId\", clientId);\n  if (ecosystem?.partnerId !== undefined) {\n    inAppWalletUrl.searchParams.set(\"partnerId\", ecosystem.partnerId);\n  }\n  if (ecosystem?.id !== undefined) {\n    inAppWalletUrl.searchParams.set(\"ecosystemId\", ecosystem.id);\n  }\n  return inAppWalletUrl;\n}\nexport const IN_APP_WALLET_IFRAME_ID = \"thirdweb-in-app-wallet-iframe\";\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthProvider,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/types.js\";\nimport type { ClientIdWithQuerierType, Ecosystem } from \"../../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\nexport type LoginQuerierTypes = {\n  loginWithCustomAuthEndpoint: { payload: string; encryptionKey: string };\n  loginWithCustomJwt: { jwt: string; encryptionKey?: string };\n  loginWithThirdwebModal: undefined | { email: string };\n  sendThirdwebSmsLoginOtp: { phoneNumber: string };\n  sendThirdwebEmailLoginOtp: { email: string };\n  verifyThirdwebEmailLoginOtp: {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  verifyThirdwebSmsLoginOtp: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  injectDeveloperClientId: undefined;\n  getHeadlessOauthLoginLink: { authProvider: AuthProvider };\n};\n\n/**\n * @internal\n */\nexport abstract class AbstractLogin<\n  MODAL = void,\n  EMAIL_MODAL extends { email: string } = { email: string },\n  EMAIL_VERIFICATION extends { email: string; otp: string } = {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  },\n> {\n  protected LoginQuerier: InAppWalletIframeCommunicator<LoginQuerierTypes>;\n  protected preLogin;\n  protected postLogin: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  protected client: ThirdwebClient;\n  protected baseUrl: string;\n  protected ecosystem?: Ecosystem;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * @internal\n   */\n  constructor({\n    baseUrl,\n    querier,\n    preLogin,\n    postLogin,\n    client,\n    ecosystem,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    preLogin: () => Promise<void>;\n    postLogin: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n    ecosystem?: Ecosystem;\n  }) {\n    this.baseUrl = baseUrl;\n    this.LoginQuerier = querier;\n    this.preLogin = preLogin;\n    this.postLogin = postLogin;\n    this.client = client;\n    this.ecosystem = ecosystem;\n  }\n\n  abstract loginWithCustomJwt(args: {\n    jwt: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithCustomAuthEndpoint(args: {\n    payload: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithModal(args?: MODAL): Promise<AuthLoginReturnType>;\n  abstract loginWithIframe(args: EMAIL_MODAL): Promise<AuthLoginReturnType>;\n\n  /**\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: LoginQuerierTypes[\"sendThirdwebEmailLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebEmailLoginOtp\",\n      params: { email },\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: LoginQuerierTypes[\"sendThirdwebSmsLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebSmsLoginOtp\",\n      params: { phoneNumber },\n    });\n    return result;\n  }\n\n  abstract loginWithEmailOtp(\n    args: EMAIL_VERIFICATION,\n  ): Promise<AuthLoginReturnType>;\n\n  abstract loginWithSmsOtp(args: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  }): Promise<AuthLoginReturnType>;\n}\n","import type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n} from \"../../../core/authentication/types.js\";\nimport { AbstractLogin, type LoginQuerierTypes } from \"./abstract-login.js\";\n\n/**\n *\n */\nexport class BaseLogin extends AbstractLogin<\n  void,\n  { email: string },\n  { email: string; otp: string; recoveryCode?: string }\n> {\n  async authenticateWithModal(): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: undefined,\n      showIframe: true,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithModal(): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.authenticateWithModal();\n    return this.postLogin(result);\n  }\n\n  async authenticateWithIframe({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: { email },\n      showIframe: true,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithIframe({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.authenticateWithIframe({ email });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithCustomJwt({\n    encryptionKey,\n    jwt,\n  }: LoginQuerierTypes[\"loginWithCustomJwt\"]): Promise<AuthAndWalletRpcReturnType> {\n    if (!encryptionKey || encryptionKey.length === 0) {\n      throw new Error(\"Encryption key is required for custom jwt auth\");\n    }\n\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomJwt\",\n      params: { encryptionKey, jwt },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomJwt({\n    encryptionKey,\n    jwt,\n  }: LoginQuerierTypes[\"loginWithCustomJwt\"]): Promise<AuthLoginReturnType> {\n    if (!encryptionKey || encryptionKey.length === 0) {\n      throw new Error(\"Encryption key is required for custom jwt auth\");\n    }\n\n    await this.preLogin();\n    const result = await this.authenticateWithCustomJwt({ encryptionKey, jwt });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithCustomAuthEndpoint({\n    encryptionKey,\n    payload,\n  }: LoginQuerierTypes[\"loginWithCustomAuthEndpoint\"]): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomAuthEndpoint\",\n      params: { encryptionKey, payload },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomAuthEndpoint({\n    encryptionKey,\n    payload,\n  }: LoginQuerierTypes[\"loginWithCustomAuthEndpoint\"]): Promise<AuthLoginReturnType> {\n    if (!encryptionKey || encryptionKey.length === 0) {\n      throw new Error(\"Encryption key is required for custom auth\");\n    }\n\n    await this.preLogin();\n    const result = await this.authenticateWithCustomAuthEndpoint({\n      encryptionKey,\n      payload,\n    });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithEmailOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebEmailLoginOtp\"]): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebEmailLoginOtp\",\n      params: { email, otp, recoveryCode },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithEmailOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebEmailLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.authenticateWithEmailOtp({\n      email,\n      otp,\n      recoveryCode,\n    });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithSmsOtp({\n    phoneNumber,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebSmsLoginOtp\"]): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebSmsLoginOtp\",\n      params: { phoneNumber, otp, recoveryCode },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithSmsOtp({\n    phoneNumber,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebSmsLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.authenticateWithSmsOtp({\n      phoneNumber,\n      otp,\n      recoveryCode,\n    });\n    return this.postLogin(result);\n  }\n}\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport { webLocalStorage } from \"../../../../../utils/storage/webStorage.js\";\nimport { ClientScopedStorage } from \"../../../core/authentication/client-scoped-storage.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthStoredTokenWithCookieReturnType,\n  LogoutReturnType,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/types.js\";\nimport type { ClientIdWithQuerierType, Ecosystem } from \"../../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { BaseLogin } from \"./base-login.js\";\n\nexport type AuthQuerierTypes = {\n  logout: undefined;\n  initIframe: {\n    partnerId?: string;\n    ecosystemId?: string;\n    clientId: string;\n    authCookie: string;\n    walletUserId: string;\n    deviceShareStored: string;\n  };\n  loginWithStoredTokenDetails: {\n    storedToken: AuthStoredTokenWithCookieReturnType[\"storedToken\"];\n    recoveryCode?: string;\n  };\n};\n\n/**\n *\n */\nexport class Auth {\n  protected client: ThirdwebClient;\n  protected AuthQuerier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n  protected localStorage: ClientScopedStorage;\n  protected onAuthSuccess: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  private BaseLogin: BaseLogin;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * @internal\n   */\n  constructor({\n    client,\n    querier,\n    onAuthSuccess,\n    ecosystem,\n    baseUrl,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    ecosystem?: Ecosystem;\n    onAuthSuccess: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n  }) {\n    this.client = client;\n\n    this.AuthQuerier = querier;\n    this.localStorage = new ClientScopedStorage({\n      storage: webLocalStorage,\n      clientId: client.clientId,\n      ecosystemId: ecosystem?.id,\n    });\n    this.onAuthSuccess = onAuthSuccess;\n    this.BaseLogin = new BaseLogin({\n      postLogin: async (result) => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      ecosystem,\n      querier: querier,\n      client,\n      baseUrl,\n    });\n  }\n\n  private async preLogin() {\n    await this.logout();\n  }\n\n  private async postLogin({\n    storedToken,\n    walletDetails,\n  }: AuthAndWalletRpcReturnType): Promise<AuthLoginReturnType> {\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails,\n    });\n    return initializedUser;\n  }\n\n  async loginWithAuthToken(\n    authToken: AuthStoredTokenWithCookieReturnType,\n    recoveryCode?: string,\n  ): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithStoredTokenDetails\",\n      params: {\n        storedToken: authToken.storedToken,\n        recoveryCode,\n      },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n   * @example\n   * ```typescript\n   * const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await thirdwebInAppWallet.auth.loginWithModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   * ```\n   * @returns `{{user: InitializedUser}}` An InitializedUser object.\n   */\n  async loginWithModal(): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithModal();\n  }\n  async authenticateWithModal(): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithModal();\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet using email OTP\n   * @example\n   * ```typescript\n   *  // Basic Flow\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await thirdwebInAppWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   * ```\n   * @param args - args.email: We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{user: InitializedUser}}` An InitializedUser object. See {@link InAppWalletSdk.getUser} for more\n   */\n  async loginWithIframe(\n    args: Parameters<BaseLogin[\"loginWithIframe\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithIframe(args);\n  }\n  async authenticateWithIframe(\n    args: Parameters<BaseLogin[\"authenticateWithIframe\"]>[0],\n  ): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithIframe(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomJwt(\n    args: Parameters<BaseLogin[\"loginWithCustomJwt\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomJwt(args);\n  }\n  async authenticateWithCustomJwt(\n    args: Parameters<BaseLogin[\"authenticateWithCustomJwt\"]>[0],\n  ): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithCustomJwt(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomAuthEndpoint(\n    args: Parameters<BaseLogin[\"loginWithCustomAuthEndpoint\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomAuthEndpoint(args);\n  }\n  async authenticateWithCustomAuthEndpoint(\n    args: Parameters<BaseLogin[\"authenticateWithCustomAuthEndpoint\"]>[0],\n  ): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithCustomAuthEndpoint(args);\n  }\n\n  /**\n   * A headless way to send the users at the passed email an OTP code.\n   * You need to then call {@link Auth.loginWithEmailOtp} in order to complete the login process\n   * @example\n   * @param param0.email\n   * ```typescript\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    await thirdwebInAppWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await thirdwebInAppWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   * ```\n   * @param param0 - param0.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{ isNewUser: boolean }}` IsNewUser indicates if the user is a new user to your platform\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: Parameters<\n    BaseLogin[\"sendEmailLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendEmailLoginOtp({\n      email,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: Parameters<\n    BaseLogin[\"sendSmsLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendSmsLoginOtp({\n      phoneNumber,\n    });\n  }\n\n  /**\n   * Used to verify the otp that the user receives from thirdweb\n   *\n   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n   * @param args - props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * props.otp The code that the user received in their email\n   * @returns `{{user: InitializedUser}}` An InitializedUser object containing the user's status, wallet, authDetails, and more\n   * @internal\n   */\n  async loginWithEmailOtp(args: Parameters<BaseLogin[\"loginWithEmailOtp\"]>[0]) {\n    await this.preLogin();\n    return this.BaseLogin.loginWithEmailOtp(args);\n  }\n  async authenticateWithEmailOtp(\n    args: Parameters<BaseLogin[\"authenticateWithEmailOtp\"]>[0],\n  ) {\n    return this.BaseLogin.authenticateWithEmailOtp(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithSmsOtp(args: Parameters<BaseLogin[\"loginWithSmsOtp\"]>[0]) {\n    await this.preLogin();\n    return this.BaseLogin.loginWithSmsOtp(args);\n  }\n  async authenticateWithSmsOtp(\n    args: Parameters<BaseLogin[\"authenticateWithSmsOtp\"]>[0],\n  ) {\n    return this.BaseLogin.authenticateWithSmsOtp(args);\n  }\n\n  /**\n   * Logs any existing user out of their wallet.\n   * @returns `{{success: boolean}}` true if a user is successfully logged out. false if there's no user currently logged in.\n   * @internal\n   */\n  async logout(): Promise<LogoutReturnType> {\n    const { success } = await this.AuthQuerier.call<LogoutReturnType>({\n      procedureName: \"logout\",\n      params: undefined,\n    });\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n\n    return {\n      success: success || isRemoveAuthCookie || isRemoveUserId,\n    };\n  }\n}\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport {\n  getLoginCallbackUrl,\n  getLoginUrl,\n} from \"../../../core/authentication/getLoginPath.js\";\nimport type {\n  AuthStoredTokenWithCookieReturnType,\n  MultiStepAuthArgsType,\n  PreAuthArgsType,\n} from \"../../../core/authentication/types.js\";\nimport type { Ecosystem } from \"../../types.js\";\n\n/**\n * @internal\n */\nexport const sendOtp = async (args: PreAuthArgsType): Promise<void> => {\n  const { client, ecosystem } = args;\n  const url = getLoginUrl({ client, ecosystem, authOption: args.strategy });\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    \"x-client-id\": client.clientId,\n  };\n\n  if (ecosystem?.id) {\n    headers[\"x-ecosystem-id\"] = ecosystem.id;\n  }\n\n  if (ecosystem?.partnerId) {\n    headers[\"x-ecosystem-partner-id\"] = ecosystem.partnerId;\n  }\n\n  const body = (() => {\n    switch (args.strategy) {\n      case \"email\":\n        return {\n          email: args.email,\n        };\n      case \"phone\":\n        return {\n          phone: args.phoneNumber,\n        };\n    }\n  })();\n\n  const response = await fetch(url, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    throw new Error(\"Failed to send verification code\");\n  }\n\n  return await response.json();\n};\n\n/**\n * @internal\n */\nexport const verifyOtp = async (\n  args: MultiStepAuthArgsType & {\n    client: ThirdwebClient;\n    ecosystem?: Ecosystem;\n  },\n): Promise<AuthStoredTokenWithCookieReturnType> => {\n  const { client, ecosystem } = args;\n  const url = getLoginCallbackUrl({\n    authOption: args.strategy,\n    client: args.client,\n    ecosystem: args.ecosystem,\n  });\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    \"x-client-id\": client.clientId,\n  };\n\n  if (ecosystem?.id) {\n    headers[\"x-ecosystem-id\"] = ecosystem.id;\n  }\n\n  if (ecosystem?.partnerId) {\n    headers[\"x-ecosystem-partner-id\"] = ecosystem.partnerId;\n  }\n\n  const body = (() => {\n    switch (args.strategy) {\n      case \"email\":\n        return {\n          email: args.email,\n          code: args.verificationCode,\n        };\n      case \"phone\":\n        return {\n          phone: args.phoneNumber,\n          code: args.verificationCode,\n        };\n    }\n  })();\n\n  const response = await fetch(url, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    throw new Error(\"Failed to verify verification code\");\n  }\n\n  return await response.json();\n};\n","import type * as ethers5 from \"ethers5\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { getThirdwebDomains } from \"../../../../utils/domains.js\";\nimport { type Hex, hexToString } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parseTypedData.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport type { Prettify } from \"../../../../utils/type-utils.js\";\nimport { getEcosystemPartnerPermissions } from \"../../../ecosystem/get-ecosystem-partner-permissions.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport {\n  type GetUser,\n  type GetUserWalletStatusRpcReturnType,\n  type SetUpWalletRpcReturnType,\n  UserWalletStatus,\n  type WalletAddressObjectType,\n} from \"../../core/authentication/types.js\";\nimport type {\n  ClientIdWithQuerierType,\n  Ecosystem,\n  GetAddressReturnType,\n  SignMessageReturnType,\n  SignTransactionReturnType,\n  SignedTypedDataReturnType,\n} from \"../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\nexport type WalletManagementTypes = {\n  createWallet: undefined;\n  setUpNewDevice: undefined;\n  getUserStatus: undefined;\n};\nexport type WalletManagementUiTypes = {\n  createWalletUi: undefined;\n  setUpNewDeviceUi: undefined;\n};\n\nexport type InAppWalletInternalHelperType = { showUi: boolean };\n\nexport type SignerProcedureTypes = {\n  getAddress: undefined;\n  signMessage: {\n    message: string | Hex;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTransaction: {\n    transaction: ethers5.ethers.providers.TransactionRequest;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTypedDataV4: {\n    domain: TypedDataDefinition[\"domain\"];\n    types: TypedDataDefinition[\"types\"];\n    message: TypedDataDefinition[\"message\"];\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  //connect: { provider: Provider };\n};\n\ntype PostWalletSetup = SetUpWalletRpcReturnType & {\n  walletUserId: string;\n};\n\n/**\n *\n */\nexport class IFrameWallet {\n  public client: ThirdwebClient;\n  public ecosystem?: Ecosystem;\n  protected walletManagerQuerier: InAppWalletIframeCommunicator<\n    WalletManagementTypes & WalletManagementUiTypes\n  >;\n  protected localStorage: ClientScopedStorage;\n\n  /**\n   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n   * @internal\n   */\n  constructor({\n    client,\n    ecosystem,\n    querier,\n  }: Prettify<\n    ClientIdWithQuerierType & {\n      ecosystem?: Ecosystem;\n    }\n  >) {\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.walletManagerQuerier = querier;\n\n    this.localStorage = new ClientScopedStorage({\n      storage: webLocalStorage,\n      clientId: client.clientId,\n      ecosystemId: ecosystem?.id,\n    });\n  }\n\n  /**\n   * Used to set-up the user device in the case that they are using incognito\n   * @returns `{walletAddress : string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp({\n    deviceShareStored,\n    walletAddress,\n    isIframeStorageEnabled,\n    walletUserId,\n  }: PostWalletSetup): Promise<WalletAddressObjectType> {\n    if (!isIframeStorageEnabled) {\n      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);\n    }\n    return { walletAddress };\n  }\n\n  /**\n   * Gets the various status states of the user\n   * @example\n   * ```typescript\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   *```\n   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n   * @internal\n   */\n  async getUserWalletStatus(): Promise<GetUser> {\n    const userStatus =\n      await this.walletManagerQuerier.call<GetUserWalletStatusRpcReturnType>({\n        procedureName: \"getUserStatus\",\n        params: undefined,\n      });\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n        ...userStatus.user,\n        account: await this.getAccount(),\n      };\n    }\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_NEW_DEVICE) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,\n        ...userStatus.user,\n      };\n    }\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,\n        ...userStatus.user,\n      };\n    }\n    // Logged out\n    return { status: userStatus.status };\n  }\n\n  /**\n   * Returns an account that communicates with the iFrame for signing operations\n   * @internal\n   */\n  async getAccount(): Promise<Account> {\n    const querier = this\n      .walletManagerQuerier as unknown as InAppWalletIframeCommunicator<SignerProcedureTypes>;\n    const client = this.client;\n    const partnerId = this.ecosystem?.partnerId;\n    const isEcosystem = !!this.ecosystem;\n\n    const permissions = this.ecosystem?.partnerId\n      ? await getEcosystemPartnerPermissions(\n          this.ecosystem.id,\n          this.ecosystem?.partnerId,\n        )\n      : undefined;\n\n    const { address } = await querier.call<GetAddressReturnType>({\n      procedureName: \"getAddress\",\n      params: undefined,\n    });\n    const _signTransaction = async (tx: SendTransactionOption) => {\n      // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n      const transaction: Record<string, any> = {\n        to: tx.to ?? undefined,\n        data: tx.data,\n        value: tx.value,\n        gasLimit: tx.gas,\n        nonce: tx.nonce,\n        chainId: tx.chainId,\n      };\n      if (tx.maxFeePerGas) {\n        // ethers (in the iframe) rejects any type 0 trasaction with unknown keys\n        // TODO remove this once iframe is upgraded to v5\n        transaction.accessList = tx.accessList;\n        transaction.maxFeePerGas = tx.maxFeePerGas;\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice;\n        transaction.type = 0;\n      }\n      const RPC_URL = getThirdwebDomains().rpc;\n      const { signedTransaction } =\n        await querier.call<SignTransactionReturnType>({\n          procedureName: \"signTransaction\",\n          params: {\n            transaction,\n            chainId: tx.chainId,\n            partnerId,\n            rpcEndpoint: `https://${tx.chainId}.${RPC_URL}`, // TODO (ew) shouldnt be needed\n          },\n          // Can hide the iframe if the partner has full control (no user approvals)\n          showIframe: permissions?.permissions.includes(\"FULL_CONTROL_V1\")\n            ? false\n            : isEcosystem,\n        });\n      return signedTransaction as Hex;\n    };\n    return {\n      address: getAddress(address),\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction({\n          ...tx,\n          chainId: tx.chainId,\n        });\n      },\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          client,\n          chain: getCachedChain(tx.chainId),\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(\n          rpcRequest,\n          signedTx,\n        );\n        return {\n          transactionHash,\n        };\n      },\n      async signMessage({ message }) {\n        // in-app wallets use ethers to sign messages, which always expects a string (or bytes maybe but string is safest)\n        const messageDecoded = (() => {\n          if (typeof message === \"string\") {\n            return message;\n          }\n          if (message.raw instanceof Uint8Array) {\n            return message.raw;\n          }\n          return hexToString(message.raw);\n        })();\n\n        const { signedMessage } = await querier.call<SignMessageReturnType>({\n          procedureName: \"signMessage\",\n          params: {\n            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n            message: messageDecoded as any, // needs bytes or string\n            partnerId,\n            chainId: 1, // TODO check if we need this\n          },\n          // Can hide the iframe if the partner has full control (no user approvals)\n          showIframe: permissions?.permissions.includes(\"FULL_CONTROL_V1\")\n            ? false\n            : isEcosystem,\n        });\n        return signedMessage as Hex;\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n        // this happens when going from viem to ethers via the iframe\n        if (parsedTypedData.types?.EIP712Domain) {\n          parsedTypedData.types.EIP712Domain = undefined;\n        }\n        const domain = parsedTypedData.domain as TypedDataDefinition[\"domain\"];\n        const chainId = domain?.chainId;\n        const domainData = {\n          verifyingContract: domain?.verifyingContract,\n          name: domain?.name,\n          version: domain?.version,\n        };\n        // chain id can't be included if it wasn't explicitly specified\n        if (chainId) {\n          (domainData as Record<string, unknown>).chainId = chainId;\n        }\n\n        const RPC_URL = getThirdwebDomains().rpc;\n        const { signedTypedData } =\n          await querier.call<SignedTypedDataReturnType>({\n            procedureName: \"signTypedDataV4\",\n            params: {\n              domain: domainData,\n              types:\n                parsedTypedData.types as SignerProcedureTypes[\"signTypedDataV4\"][\"types\"],\n              message:\n                parsedTypedData.message as SignerProcedureTypes[\"signTypedDataV4\"][\"message\"],\n              chainId: chainId || 1,\n              partnerId,\n              rpcEndpoint: `https://${chainId}.${RPC_URL}`, // TODO (ew) shouldnt be needed\n            },\n            // Can hide the iframe if the partner has full control (no user approvals)\n            showIframe: permissions?.permissions.includes(\"FULL_CONTROL_V1\")\n              ? false\n              : isEcosystem,\n          });\n        return signedTypedData as Hex;\n      },\n    };\n  }\n}\n","import { getThirdwebBaseUrl } from \"../../utils/domains.js\";\nimport type { EcosystemPermssions } from \"../in-app/web/types.js\";\nimport type { EcosystemWalletId } from \"../wallet-types.js\";\n\nexport const getEcosystemPartnerPermissions = async (\n  ecosystemId: EcosystemWalletId,\n  partnerId?: string,\n): Promise<EcosystemPermssions> => {\n  const res = await fetch(\n    `${getThirdwebBaseUrl(\n      \"inAppWallet\",\n    )}/api/2024-05-05/ecosystem-wallet/${ecosystemId}/partner/${partnerId}`,\n    {\n      headers: {\n        \"x-ecosystem-id\": ecosystemId,\n        \"x-ecosystem-partner-id\": partnerId || \"\",\n      },\n    },\n  );\n\n  const data = (await res.json()) as EcosystemPermssions;\n\n  return data;\n};\n","import type { EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\n/**\n * Sends a raw transaction to the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param signedTransaction - The signed transaction in hex format.\n * @returns A promise that resolves to the transaction hash.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_sendRawTransaction } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionHash = await eth_sendRawTransaction(rpcRequest, \"0x...\");\n * ```\n */\nexport async function eth_sendRawTransaction(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  signedTransaction: Hex,\n) {\n  return await request({\n    method: \"eth_sendRawTransaction\",\n    params: [signedTransaction],\n  });\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport type { SocialAuthOption } from \"../../../../wallets/types.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\nimport {\n  loginWithPasskey,\n  registerPasskey,\n} from \"../../core/authentication/passkeys.js\";\nimport { siweAuthenticate } from \"../../core/authentication/siwe.js\";\nimport {\n  type AuthLoginReturnType,\n  type AuthStoredTokenWithCookieReturnType,\n  type GetUser,\n  type LogoutReturnType,\n  type MultiStepAuthArgsType,\n  type MultiStepAuthProviderType,\n  type SingleStepAuthArgsType,\n  UserWalletStatus,\n} from \"../../core/authentication/types.js\";\nimport type { InAppConnector } from \"../../core/interfaces/connector.js\";\nimport type { InAppWalletConstructorType } from \"../types.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth, type AuthQuerierTypes } from \"./auth/iframe-auth.js\";\nimport { loginWithOauth, loginWithOauthRedirect } from \"./auth/oauth.js\";\nimport { sendOtp, verifyOtp } from \"./auth/otp.js\";\nimport { IFrameWallet } from \"./in-app-account.js\";\n\n/**\n * @internal\n */\nexport class InAppWebConnector implements InAppConnector {\n  protected client: ThirdwebClient;\n  protected querier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n\n  private wallet: IFrameWallet;\n  /**\n   * Used to manage the Auth state of the user.\n   */\n  auth: Auth;\n  private passkeyDomain?: string;\n\n  private isClientIdLegacyPaper(clientId: string): boolean {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @example\n   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n   * @internal\n   */\n  constructor({\n    client,\n    onAuthSuccess,\n    ecosystem,\n    passkeyDomain,\n  }: InAppWalletConstructorType) {\n    if (this.isClientIdLegacyPaper(client.clientId)) {\n      throw new Error(\n        \"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\",\n      );\n    }\n    const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n    this.client = client;\n    this.passkeyDomain = passkeyDomain;\n    this.querier = new InAppWalletIframeCommunicator({\n      clientId: client.clientId,\n      ecosystem,\n      baseUrl,\n    });\n    this.wallet = new IFrameWallet({\n      client,\n      ecosystem,\n      querier: this.querier,\n    });\n\n    this.auth = new Auth({\n      client,\n      querier: this.querier,\n      baseUrl,\n      ecosystem,\n      onAuthSuccess: async (authResult) => {\n        onAuthSuccess?.(authResult);\n        await this.wallet.postWalletSetUp({\n          ...authResult.walletDetails,\n          walletUserId: authResult.storedToken.authDetails.userWalletId,\n        });\n        await this.querier.call({\n          procedureName: \"initIframe\",\n          params: {\n            partnerId: ecosystem?.partnerId,\n            ecosystemId: ecosystem?.id,\n            deviceShareStored: authResult.walletDetails.deviceShareStored,\n            clientId: this.client.clientId,\n            walletUserId: authResult.storedToken.authDetails.userWalletId,\n            authCookie: authResult.storedToken.cookieString,\n          },\n        });\n        return {\n          user: {\n            status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n            authDetails: authResult.storedToken.authDetails,\n            account: await this.wallet.getAccount(),\n            walletAddress: authResult.walletDetails.walletAddress,\n          },\n        };\n      },\n    });\n  }\n\n  /**\n   * Gets the user if they're logged in\n   * @example\n   * ```js\n   *  const user = await thirdwebInAppWallet.getUser();\n   *  switch (user.status) {\n   *     case UserWalletStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   * }\n   * ```\n   * @returns GetUser - an object to containing various information on the user statuses\n   */\n  async getUser(): Promise<GetUser> {\n    return this.wallet.getUserWalletStatus();\n  }\n\n  getAccount(): Promise<Account> {\n    return this.wallet.getAccount();\n  }\n\n  async preAuthenticate(args: MultiStepAuthProviderType): Promise<void> {\n    return sendOtp({\n      ...args,\n      client: this.wallet.client,\n      ecosystem: this.wallet.ecosystem,\n    });\n  }\n\n  authenticateWithRedirect(strategy: SocialAuthOption): void {\n    loginWithOauthRedirect({\n      authOption: strategy,\n      client: this.wallet.client,\n      ecosystem: this.wallet.ecosystem,\n    });\n  }\n\n  async loginWithAuthToken(authResult: AuthStoredTokenWithCookieReturnType) {\n    return this.auth.loginWithAuthToken(authResult);\n  }\n\n  /**\n   * Authenticates the user and returns the auth token, but does not instantiate their wallet\n   */\n  async authenticate(\n    args: MultiStepAuthArgsType | SingleStepAuthArgsType,\n  ): Promise<AuthStoredTokenWithCookieReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\":\n        return verifyOtp({\n          ...args,\n          client: this.wallet.client,\n          ecosystem: this.wallet.ecosystem,\n        });\n      case \"phone\":\n        return verifyOtp({\n          ...args,\n          client: this.wallet.client,\n          ecosystem: this.wallet.ecosystem,\n        });\n      case \"jwt\":\n        return this.auth.authenticateWithCustomJwt({\n          jwt: args.jwt,\n          encryptionKey: args.encryptionKey,\n        });\n      case \"passkey\": {\n        return this.passkeyAuth(args);\n      }\n      case \"auth_endpoint\": {\n        return this.auth.authenticateWithCustomAuthEndpoint({\n          payload: args.payload,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.authenticateWithIframe({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.authenticateWithModal();\n      }\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"telegram\":\n      case \"farcaster\":\n      case \"discord\": {\n        return loginWithOauth({\n          authOption: strategy,\n          client: this.wallet.client,\n          ecosystem: this.wallet.ecosystem,\n          closeOpenedWindow: args.closeOpenedWindow,\n          openedWindow: args.openedWindow,\n        });\n      }\n      case \"wallet\": {\n        return siweAuthenticate({\n          ecosystem: this.wallet.ecosystem,\n          client: this.wallet.client,\n          wallet: args.wallet,\n          chain: args.chain,\n        });\n      }\n    }\n  }\n\n  /**\n   * Authenticates the user then instantiates their wallet using the resulting auth token\n   */\n  async connect(\n    args: MultiStepAuthArgsType | SingleStepAuthArgsType,\n  ): Promise<AuthLoginReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"jwt\": {\n        return this.auth.loginWithCustomJwt({\n          jwt: args.jwt,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"auth_endpoint\": {\n        return this.auth.loginWithCustomAuthEndpoint({\n          payload: args.payload,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.loginWithIframe({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.loginWithModal();\n      }\n      case \"passkey\": {\n        const authToken = await this.passkeyAuth(args);\n        return this.loginWithAuthToken(authToken);\n      }\n      case \"phone\":\n      case \"email\":\n      case \"wallet\":\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"farcaster\":\n      case \"telegram\":\n      case \"discord\": {\n        const authToken = await this.authenticate(args);\n        return this.auth.loginWithAuthToken(authToken);\n      }\n\n      default:\n        assertUnreachable(strategy);\n    }\n  }\n\n  async logout(): Promise<LogoutReturnType> {\n    return await this.auth.logout();\n  }\n\n  private async passkeyAuth(\n    args: Extract<SingleStepAuthArgsType, { strategy: \"passkey\" }>,\n  ) {\n    const { PasskeyWebClient } = await import(\"./auth/passkeys.js\");\n    const passkeyClient = new PasskeyWebClient();\n    const storage = webLocalStorage;\n    if (args.type === \"sign-up\") {\n      return registerPasskey({\n        client: this.wallet.client,\n        ecosystem: this.wallet.ecosystem,\n        username: args.passkeyName,\n        passkeyClient,\n        storage,\n        rp: {\n          id: this.passkeyDomain ?? window.location.hostname,\n          name: this.passkeyDomain ?? window.document.title,\n        },\n      });\n    }\n    return loginWithPasskey({\n      client: this.wallet.client,\n      ecosystem: this.wallet.ecosystem,\n      passkeyClient,\n      storage,\n      rp: {\n        id: args.domain?.hostname ?? window.location.hostname,\n        name: args.domain?.displayName ?? window.document.title,\n      },\n    });\n  }\n}\n\nfunction assertUnreachable(x: never, message?: string): never {\n  throw new Error(message ?? `Invalid param: ${x}`);\n}\n","import { signLoginPayload } from \"../../../../auth/core/sign-login-payload.js\";\nimport type { LoginPayload } from \"../../../../auth/core/types.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { Wallet } from \"../../../interfaces/wallet.js\";\nimport type { Ecosystem } from \"../../web/types.js\";\nimport { getLoginCallbackUrl, getLoginUrl } from \"./getLoginPath.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"./types.js\";\n\n/**\n * @internal\n */\nexport async function siweAuthenticate(args: {\n  wallet: Wallet;\n  chain: Chain;\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  const { wallet, chain } = args;\n  const account = await wallet.connect({ client: args.client });\n  const clientFetch = getClientFetch(args.client, args.ecosystem);\n\n  const payload = await (async () => {\n    const path = getLoginUrl({\n      authOption: \"wallet\",\n      client: args.client,\n      ecosystem: args.ecosystem,\n    });\n    const res = await clientFetch(\n      `${path}&address=${account.address}&chainId=${chain.id}`,\n    );\n\n    if (!res.ok) throw new Error(\"Failed to generate SIWE login payload\");\n\n    return (await res.json()) satisfies LoginPayload;\n  })();\n  const { signature } = await signLoginPayload({ payload, account });\n\n  const authResult = await (async () => {\n    const path = getLoginCallbackUrl({\n      authOption: \"wallet\",\n      client: args.client,\n      ecosystem: args.ecosystem,\n    });\n    const res = await clientFetch(\n      `${path}&signature=${signature}&payload=${encodeURIComponent(payload)}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          signature,\n          payload,\n        }),\n      },\n    );\n\n    if (!res.ok) throw new Error(\"Failed to verify SIWE signature\");\n\n    return (await res.json()) satisfies AuthStoredTokenWithCookieReturnType;\n  })();\n  return authResult;\n}\n"],"names":["createLoginMessage","payload","prefix","concat","domain","address","join","statement","suffixArray","uri","uriField","push","versionField","version","chain_id","chainField","nonceField","nonce","issuedAtField","issued_at","expiryField","expiration_time","invalid_before","invalidBeforeField","resources","map","x","async","signLoginPayload","options","account","signature","signMessage","message","getLoginOptionRoute","option","authOptions","includes","Error","getLoginUrl","_ref","authOption","client","ecosystem","mode","redirectUrl","route","baseUrl","getThirdwebBaseUrl","clientId","partnerId","id","formattedRedirectUrl","URL","window","location","href","searchParams","set","encodeURIComponent","toString","getLoginCallbackUrl","_ref2","closeWindow","isWindowOpenedByFn","win","closeOpenedWindow","close","loginWithOauthRedirect","loginUrl","redirectExternally","open","loginWithOauth","openedWindow","Promise","resolve","reject","pollTimer","setInterval","closed","clearInterval","removeEventListener","messageListener","event","origin","data","eventType","authResult","errorString","addEventListener","getVerificationPath","getChallengePath","type","username","registerPasskey","_options$ecosystem","_options$username","_options$ecosystem2","_options$ecosystem3","passkeyClient","isAvailable","storage","ClientScopedStorage","ecosystemId","fetchWithId","getClientFetch","generatedName","_ecosystem$id","Date","toISOString","generateUsername","res","challengeData","json","challenge","registration","register","name","rp","customHeaders","verifRes","method","headers","body","JSON","stringify","authenticatorData","credentialId","serverVerificationId","clientData","credential","publicKey","algorithm","rpId","verifData","_verifData$message","storedToken","savePasskeyCredentialId","sleep","seconds","setTimeout","iframeBaseStyle","height","width","border","backgroundColor","colorScheme","position","top","right","zIndex","display","isIframeLoaded","Map","IframeCommunicator","constructor","link","iframeId","container","document","onIframeInitialize","Object","defineProperty","this","iframeBaseUrl","iframe","getElementById","hrefLink","src","createElement","mergedIframeStyles","assign","style","setAttribute","appendChild","onIframeLoaded","console","warn","onIframeLoadHandler","onIframeLoadedInitVariables","_iframe$contentWindow","channel","MessageChannel","promise","rej","port1","onmessage","success","error","contentWindow","postMessage","port2","call","_this$iframe$contentW","procedureName","params","showIframe","get","POLLING_INTERVAL_SECONDS","destroy","delete","InAppWalletIframeCommunicator","super","IN_APP_WALLET_IFRAME_ID","createInAppWalletIframeLink","path","IN_APP_WALLET_PATH","_this$ecosystem","_this$ecosystem2","_this$ecosystem3","localStorage","webLocalStorage","authCookie","getAuthCookie","deviceShareStored","getDeviceShare","walletUserId","getWalletUserId","queryParams","inAppWalletUrl","queryKey","keys","_queryParams$queryKey","undefined","AbstractLogin","querier","preLogin","postLogin","LoginQuerier","sendEmailLoginOtp","email","sendSmsLoginOtp","_ref3","phoneNumber","BaseLogin","authenticateWithModal","loginWithModal","result","authenticateWithIframe","loginWithIframe","authenticateWithCustomJwt","encryptionKey","jwt","length","loginWithCustomJwt","_ref4","authenticateWithCustomAuthEndpoint","_ref5","loginWithCustomAuthEndpoint","_ref6","authenticateWithEmailOtp","_ref7","otp","recoveryCode","loginWithEmailOtp","_ref8","authenticateWithSmsOtp","_ref9","loginWithSmsOtp","_ref10","Auth","onAuthSuccess","AuthQuerier","logout","walletDetails","shouldStoreCookieString","saveAuthCookie","cookieString","loginWithAuthToken","authToken","args","isRemoveAuthCookie","removeAuthCookie","isRemoveUserId","removeWalletUserId","verifyOtp","url","strategy","code","verificationCode","phone","response","fetch","ok","IFrameWallet","walletManagerQuerier","postWalletSetUp","walletAddress","isIframeStorageEnabled","saveDeviceShare","getUserWalletStatus","userStatus","status","UserWalletStatus","LOGGED_IN_WALLET_INITIALIZED","user","getAccount","LOGGED_IN_NEW_DEVICE","LOGGED_IN_WALLET_UNINITIALIZED","isEcosystem","permissions","getEcosystemPartnerPermissions","_signTransaction","_tx$to","transaction","to","tx","value","gasLimit","gas","chainId","maxFeePerGas","accessList","maxPriorityFeePerGas","gasPrice","RPC_URL","getThirdwebDomains","rpc","signedTransaction","rpcEndpoint","getAddress","signTransaction","sendTransaction","rpcRequest","getRpcClient","chain","getCachedChain","signedTx","transactionHash","request","eth_sendRawTransaction","messageDecoded","raw","Uint8Array","hexToString","signedMessage","signTypedData","_typedData","_parsedTypedData$type","parsedTypedData","parseTypedData","types","EIP712Domain","domainData","verifyingContract","signedTypedData","InAppWebConnector","isClientIdLegacyPaper","indexOf","passkeyDomain","wallet","auth","authDetails","userWalletId","getUser","preAuthenticate","sendOtp","authenticateWithRedirect","authenticate","passkeyAuth","connect","clientFetch","siweAuthenticate","assertUnreachable","_args$domain$hostname","_args$domain","_args$domain$displayN","_args$domain2","PasskeyWebClient","_this$passkeyDomain","_this$passkeyDomain2","passkeyName","hostname","title","_options$ecosystem4","_await$storage$getPas","_options$ecosystem5","_options$ecosystem6","getPasskeyCredentialId","authentication","_verifData$message2","loginWithPasskey","displayName"],"sourceRoot":""}