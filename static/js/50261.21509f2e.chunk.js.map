{"version":3,"file":"static/js/50261.21509f2e.chunk.js","mappings":"8IAQO,MAAMA,EAAc,aACrBC,EAAY,GACZC,EAAa,CACjB,CACEC,KAAM,UAqDHC,eAAeC,EAASC,GAC7B,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACT,EAAaC,EAAWC,GACjCQ,OAAQ,IAEZ,C,sECvDO,MAAMV,EAAc,aACrBC,EAAY,CAChB,CACEE,KAAM,UACNQ,KAAM,aAGJT,EAAa,CACjB,CACEC,KAAM,YA6FHC,eAAeQ,EACpBN,GAEA,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACT,EAAaC,EAAWC,GACjCQ,OAAQ,CAACJ,EAAQO,UAErB,C,cCvFOT,eAAeU,EACpBR,GAEA,MAAOS,EAAYC,SAA0BC,QAAQC,IAAI,CACvDN,EAAUN,IACVa,EAAAA,EAAAA,qBAAoBb,KAEtB,MAAO,IACFU,EACHI,MAAOL,EACPM,cAAcC,EAAAA,EAAAA,IAASP,EAAYC,EAAiBX,UAExD,C,yFC3CO,MAAML,EAAc,aACrBC,EAAY,GACZC,EAAa,CACjB,CACEC,KAAM,WCIHC,eAAeO,EAAKL,GACzB,OAAOiB,EAAAA,EAAAA,IAAU,IDgDZnB,eAAoBE,GACzB,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACT,EAAaC,EAAWC,GACjCQ,OAAQ,IAEZ,CCtDyBc,CAAclB,IAAU,CAC7CmB,SAAU,GAAFC,OAAKpB,EAAQE,SAASmB,MAAMC,GAAE,KAAAF,OAAIpB,EAAQE,SAASK,QAAO,SAElEgB,UAAWC,OAAOC,mBAEtB,CCdO,MAAM/B,EAAc,aACrBC,EAAY,GACZC,EAAa,CACjB,CACEC,KAAM,WCIHC,eAAe4B,EAAO1B,GAC3B,OAAOiB,EAAAA,EAAAA,IAAU,IDgDZnB,eAAsBE,GAC3B,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACT,EAAaC,EAAWC,GACjCQ,OAAQ,IAEZ,CCtDyBuB,CAAgB3B,IAAU,CAC/CmB,SAAU,GAAFC,OAAKpB,EAAQE,SAASmB,MAAMC,GAAE,KAAAF,OAAIpB,EAAQE,SAASK,QAAO,WAElEgB,UAAWC,OAAOC,mBAEtB,C,eCKO3B,eAAee,EACpBb,GAGA,IAAI4B,EAAAA,EAAAA,IAAqB5B,EAAQE,SAASK,SACxC,MAAO,CACLF,KAAM,QACNqB,OAAQ,MACR3B,SAAU,MAEPC,EAAQE,SAASmB,MAAMQ,gBAI9B,IACE,MAAOC,EAAOC,EAASC,SAAmBrB,QAAQC,IAAI,CACpDP,EAAKL,GAASiC,OAAM,IAAM,KAC1BP,EAAO1B,IACPD,EAAAA,EAAAA,IAASC,KAGX,MAAO,CACLK,KAAMyB,EACNJ,OAAQK,EACRhC,SAAUiC,EAEd,CAAE,MAAOE,GACP,MAAM,IAAIC,MAAM,yBAClB,CACF,C","sources":["../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/decimals.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/balanceOf.ts","../node_modules/thirdweb/src/extensions/erc20/read/getBalance.ts","../node_modules/thirdweb/src/extensions/common/__generated__/IContractMetadata/read/name.ts","../node_modules/thirdweb/src/extensions/common/read/name.ts","../node_modules/thirdweb/src/extensions/common/__generated__/IContractMetadata/read/symbol.ts","../node_modules/thirdweb/src/extensions/common/read/symbol.ts","../node_modules/thirdweb/src/extensions/erc20/read/getCurrencyMetadata.ts"],"sourcesContent":["import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x313ce567\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint8\",\n  },\n] as const;\n\n/**\n * Checks if the `decimals` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `decimals` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isDecimalsSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = await isDecimalsSupported(contract);\n * ```\n */\nexport async function isDecimalsSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the decimals function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeDecimalsResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeDecimalsResult(\"...\");\n * ```\n */\nexport function decodeDecimalsResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"decimals\" function on the contract.\n * @param options - The options for the decimals function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const result = await decimals({\n *  contract,\n * });\n *\n * ```\n */\nexport async function decimals(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"balanceOf\" function.\n */\nexport type BalanceOfParams = {\n  address: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"_address\" }>;\n};\n\nexport const FN_SELECTOR = \"0x70a08231\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"_address\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `balanceOf` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `balanceOf` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isBalanceOfSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = await isBalanceOfSupported(contract);\n * ```\n */\nexport async function isBalanceOfSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"balanceOf\" function.\n * @param options - The options for the balanceOf function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeBalanceOfParams } \"thirdweb/extensions/erc20\";\n * const result = encodeBalanceOfParams({\n *  address: ...,\n * });\n * ```\n */\nexport function encodeBalanceOfParams(options: BalanceOfParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.address]);\n}\n\n/**\n * Encodes the \"balanceOf\" function into a Hex string with its parameters.\n * @param options - The options for the balanceOf function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeBalanceOf } \"thirdweb/extensions/erc20\";\n * const result = encodeBalanceOf({\n *  address: ...,\n * });\n * ```\n */\nexport function encodeBalanceOf(options: BalanceOfParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeBalanceOfParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the balanceOf function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeBalanceOfResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeBalanceOfResult(\"...\");\n * ```\n */\nexport function decodeBalanceOfResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"balanceOf\" function on the contract.\n * @param options - The options for the balanceOf function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { balanceOf } from \"thirdweb/extensions/erc20\";\n *\n * const result = await balanceOf({\n *  contract,\n *  address: ...,\n * });\n *\n * ```\n */\nexport async function balanceOf(\n  options: BaseTransactionOptions<BalanceOfParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.address],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { toTokens } from \"../../../utils/units.js\";\nimport { balanceOf } from \"../__generated__/IERC20/read/balanceOf.js\";\nimport { getCurrencyMetadata } from \"./getCurrencyMetadata.js\";\n/**\n * Represents the parameters for retrieving the balance of an address.\n * @extension ERC20\n */\nexport type GetBalanceParams = {\n  /**\n   * The address for which to retrieve the balance.\n   */\n  address: string;\n};\n\n/**\n * Represents the result of a balance query for an ERC20 token.\n * @extension ERC20\n */\nexport type GetBalanceResult = {\n  value: bigint;\n  decimals: number;\n  displayValue: string;\n  symbol: string;\n  name: string;\n};\n\n/**\n * Retrieves the balance of an ERC20 token for a specific address.\n * @param options - The transaction options including the address.\n * @returns An object containing the balance value, display value, and symbol.\n * @extension ERC20\n * @example\n * ```ts\n * import { getBalance } from \"thirdweb/extensions/erc20\";\n *\n * const balance = await getBalance({ contract, address: \"0x...\" });\n * ```\n */\nexport async function getBalance(\n  options: BaseTransactionOptions<GetBalanceParams>,\n): Promise<GetBalanceResult> {\n  const [balanceWei, currencyMetadata] = await Promise.all([\n    balanceOf(options),\n    getCurrencyMetadata(options),\n  ]);\n  return {\n    ...currencyMetadata,\n    value: balanceWei,\n    displayValue: toTokens(balanceWei, currencyMetadata.decimals),\n  };\n}\n","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x06fdde03\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `name` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `name` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isNameSupported } from \"thirdweb/extensions/common\";\n *\n * const supported = await isNameSupported(contract);\n * ```\n */\nexport async function isNameSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the name function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeNameResult } from \"thirdweb/extensions/common\";\n * const result = decodeNameResult(\"...\");\n * ```\n */\nexport function decodeNameResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"name\" function on the contract.\n * @param options - The options for the name function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const result = await name({\n *  contract,\n * });\n *\n * ```\n */\nexport async function name(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { name as generatedName } from \"../__generated__/IContractMetadata/read/name.js\";\n\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const contractName = await name({ contract });\n * ```\n */\nexport async function name(options: BaseTransactionOptions): Promise<string> {\n  return withCache(() => generatedName(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:name`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x95d89b41\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `symbol` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `symbol` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isSymbolSupported } from \"thirdweb/extensions/common\";\n *\n * const supported = await isSymbolSupported(contract);\n * ```\n */\nexport async function isSymbolSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the symbol function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeSymbolResult } from \"thirdweb/extensions/common\";\n * const result = decodeSymbolResult(\"...\");\n * ```\n */\nexport function decodeSymbolResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"symbol\" function on the contract.\n * @param options - The options for the symbol function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const result = await symbol({\n *  contract,\n * });\n *\n * ```\n */\nexport async function symbol(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { symbol as generatedSymbol } from \"../__generated__/IContractMetadata/read/symbol.js\";\n\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const contractSymbol = await symbol({ contract });\n * ```\n */\nexport async function symbol(options: BaseTransactionOptions): Promise<string> {\n  return withCache(() => generatedSymbol(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:symbol`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n","import { isNativeTokenAddress } from \"../../../constants/addresses.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { name } from \"../../common/read/name.js\";\nimport { symbol } from \"../../common/read/symbol.js\";\nimport { decimals } from \"../__generated__/IERC20/read/decimals.js\";\n\n/**\n * @extension ERC20\n */\nexport type GetCurrencyMetadataResult = {\n  name: string;\n  symbol: string;\n  decimals: number;\n};\n\n/**\n * Retrieves the metadata of a currency.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to an object containing the currency metadata.\n * @extension ERC20\n * @example\n * ```ts\n * import { getCurrencyMetadata } from \"thirdweb/extensions/erc20\";\n *\n * const currencyMetadata = await getCurrencyMetadata({ contract });\n * ```\n */\nexport async function getCurrencyMetadata(\n  options: BaseTransactionOptions,\n): Promise<GetCurrencyMetadataResult> {\n  // if the contract is the native token, return the native currency metadata\n  if (isNativeTokenAddress(options.contract.address)) {\n    return {\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18,\n      // overwrite with native currency of the chain if available\n      ...options.contract.chain.nativeCurrency,\n    };\n  }\n\n  try {\n    const [name_, symbol_, decimals_] = await Promise.all([\n      name(options).catch(() => \"\"),\n      symbol(options),\n      decimals(options),\n    ]);\n\n    return {\n      name: name_,\n      symbol: symbol_,\n      decimals: decimals_,\n    };\n  } catch (e) {\n    throw new Error(\"Invalid currency token\");\n  }\n}\n"],"names":["FN_SELECTOR","FN_INPUTS","FN_OUTPUTS","type","async","decimals","options","readContract","contract","method","params","name","balanceOf","address","getBalance","balanceWei","currencyMetadata","Promise","all","getCurrencyMetadata","value","displayValue","toTokens","withCache","generatedName","cacheKey","concat","chain","id","cacheTime","Number","POSITIVE_INFINITY","symbol","generatedSymbol","isNativeTokenAddress","nativeCurrency","name_","symbol_","decimals_","catch","e","Error"],"sourceRoot":""}