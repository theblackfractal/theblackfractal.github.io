{"version":3,"file":"static/js/42624.fa467111.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/utils/encoding/helpers/concat-hex.ts","../node_modules/viem/constants/number.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/allowance.ts","../node_modules/thirdweb/src/utils/bigint.ts","../node_modules/thirdweb/src/transaction/actions/zksync/getEip721Domain.ts","../node_modules/thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts","../node_modules/viem/utils/hash/toEventSelector.ts","../node_modules/viem/utils/abi/decodeEventLog.ts","../node_modules/viem/utils/abi/getAbiItem.ts","../node_modules/viem/utils/abi/parseEventLogs.ts","../node_modules/viem/utils/address/isAddressEqual.ts","../node_modules/viem/errors/log.ts","../node_modules/viem/utils/abi/encodeEventTopics.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts","../node_modules/thirdweb/src/event/prepare-event.ts","../node_modules/thirdweb/src/event/utils.ts","../node_modules/thirdweb/src/wallets/smart/lib/utils.ts","../node_modules/thirdweb/src/wallets/smart/lib/bundler.ts","../node_modules/thirdweb/src/wallets/smart/types.ts","../node_modules/thirdweb/src/event/actions/parse-logs.ts","../node_modules/thirdweb/src/wallets/smart/lib/calls.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getNonce.ts","../node_modules/thirdweb/src/wallets/smart/lib/paymaster.ts","../node_modules/thirdweb/src/wallets/smart/lib/userop.ts","../node_modules/thirdweb/src/wallets/smart/index.ts","../node_modules/viem/utils/encoding/toRlp.ts","../node_modules/viem/utils/signature/hashTypedData.ts"],"sourcesContent":["import type { Hex } from \"./is-hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace(\"0x\", \"\"),\n    \"\",\n  )}`;\n}\n","export const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"allowance\" function.\n */\nexport type AllowanceParams = {\n  owner: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"owner\" }>;\n  spender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"spender\" }>;\n};\n\nexport const FN_SELECTOR = \"0xdd62ed3e\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"owner\",\n  },\n  {\n    type: \"address\",\n    name: \"spender\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `allowance` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `allowance` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isAllowanceSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = await isAllowanceSupported(contract);\n * ```\n */\nexport async function isAllowanceSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"allowance\" function.\n * @param options - The options for the allowance function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowanceParams } \"thirdweb/extensions/erc20\";\n * const result = encodeAllowanceParams({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowanceParams(options: AllowanceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.owner, options.spender]);\n}\n\n/**\n * Encodes the \"allowance\" function into a Hex string with its parameters.\n * @param options - The options for the allowance function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowance } \"thirdweb/extensions/erc20\";\n * const result = encodeAllowance({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowance(options: AllowanceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeAllowanceParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the allowance function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeAllowanceResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeAllowanceResult(\"...\");\n * ```\n */\nexport function decodeAllowanceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"allowance\" function on the contract.\n * @param options - The options for the allowance function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { allowance } from \"thirdweb/extensions/erc20\";\n *\n * const result = await allowance({\n *  contract,\n *  owner: ...,\n *  spender: ...,\n * });\n *\n * ```\n */\nexport async function allowance(\n  options: BaseTransactionOptions<AllowanceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.owner, options.spender],\n  });\n}\n","import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n","import type { TransactionSerializable } from \"viem\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type {\n  EIP712SerializedTransaction,\n  EIP712TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP712TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP712SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    // TODO suport factoryDeps\n    factoryDeps: [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n","import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\nexport type SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit);\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\n\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = abi.find(\n    (x) =>\n      x.type === 'event' &&\n      signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: nonIndexedInputs,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\nimport { getAbiItem } from './getAbiItem.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = getAbiItem({\n          abi: abi as Abi,\n          name: log.topics[0] as string,\n        }) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (!value) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (!value) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import { BaseError } from './base.js'\n\nexport type FilterTypeNotSupportedErrorType = FilterTypeNotSupportedError & {\n  name: 'FilterTypeNotSupportedError'\n}\nexport class FilterTypeNotSupportedError extends BaseError {\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`, {\n      name: 'FilterTypeNotSupportedError',\n    })\n  }\n}\n","import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  ExtractAbiEvents,\n} from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeEventTopics'\n\nexport type EncodeEventTopicsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  ///\n  hasEvents = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiEvents<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>\n  >,\n  allErrorNames = ContractEventName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { eventName?: eventName | allErrorNames | undefined }\n      : { eventName: eventName | allErrorNames }\n    : { eventName?: eventName | allErrorNames | undefined }\n> &\n  (hasEvents extends true ? unknown : never)\n\nexport type EncodeEventTopicsReturnType = [Hex, ...(Hex | Hex[] | null)[]]\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n>(\n  parameters: EncodeEventTopicsParameters<abi, eventName>,\n): EncodeEventTopicsReturnType {\n  const { abi, eventName, args } = parameters as EncodeEventTopicsParameters\n\n  let abiItem = abi[0]\n  if (eventName) {\n    const item = getAbiItem({ abi, name: eventName })\n    if (!item) throw new AbiEventNotFoundError(eventName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toEventSelector(definition as EventDefinition)\n\n  let topics: (Hex | Hex[] | null)[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? indexedInputs?.map((x: any) => (args as any)[x.name]) ?? []\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) => {\n          if (Array.isArray(args_[i]))\n            return args_[i].map((_: any, j: number) =>\n              encodeArg({ param, value: args_[i][j] }),\n            )\n          return args_[i] ? encodeArg({ param, value: args_[i] }) : null\n        }) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n","import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { type Hex, encodeEventTopics, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n","import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n","import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport { isHex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type { UserOperation, UserOperationHexed } from \"../types.js\";\n\nexport const generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport const randomNonce = () => {\n  return BigInt(\n    concat([numberToHex(generateRandomUint192()), \"0x0000000000000000\"]),\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(userOp: UserOperation): UserOperationHexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationHexed;\n}\n\nexport function isNativeAAChain(chain: Chain) {\n  return (\n    chain.id === 324 ||\n    chain.id === 300 ||\n    chain.id === 302 ||\n    chain.id === 11124\n  );\n}\n","import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport {\n  type BundlerOptions,\n  type EstimationResult,\n  type GasPriceResult,\n  type PmTransactionData,\n  type UserOperation,\n  type UserOperationReceipt,\n  formatUserOperationReceipt,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: hexToBigInt(res.verificationGas),\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n  };\n}\n\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<TransactionReceipt | undefined> {\n  const res = await getUserOpReceiptRaw(args);\n\n  if (!res) {\n    return undefined;\n  }\n\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(\n        `UserOp failed at txHash: ${res.receipt.transactionHash}`,\n      );\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.receipt.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<UserOperationReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    options: args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  return formatUserOperationReceipt(res as UserOperationReceipt);\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const bundlerUrl = options.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = JSON.stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n","import type { Address } from \"abitype\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\n\nexport type SmartWalletOptions = Prettify<\n  {\n    chain: Chain; // TODO consider making default chain optional\n    factoryAddress?: string;\n    overrides?: {\n      bundlerUrl?: string;\n      accountAddress?: string;\n      accountSalt?: string;\n      entrypointAddress?: string;\n      erc20Paymaster?: {\n        address: string;\n        token: string;\n      };\n      paymaster?: (userOp: UserOperation) => Promise<PaymasterResult>;\n      predictAddress?: (factoryContract: ThirdwebContract) => Promise<string>;\n      createAccount?: (\n        factoryContract: ThirdwebContract,\n      ) => PreparedTransaction;\n      execute?: (\n        accountContract: ThirdwebContract,\n        transaction: SendTransactionOption,\n      ) => PreparedTransaction;\n      executeBatch?: (\n        accountContract: ThirdwebContract,\n        transactions: SendTransactionOption[],\n      ) => PreparedTransaction;\n      getAccountNonce?: (accountContract: ThirdwebContract) => Promise<bigint>;\n    };\n  } & (\n    | {\n        /**\n         * @deprecated use 'sponsorGas' instead\n         */\n        gasless: boolean;\n      }\n    | {\n        sponsorGas: boolean;\n      }\n  )\n>;\n\n// internal type\nexport type SmartAccountOptions = Prettify<\n  Omit<SmartWalletOptions, \"chain\" | \"gasless\" | \"sponsorGas\"> & {\n    chain: Chain;\n    sponsorGas: boolean;\n    personalAccount: Account;\n    factoryContract: ThirdwebContract;\n    accountContract: ThirdwebContract;\n    client: ThirdwebClient;\n  }\n>;\n\nexport type BundlerOptions = {\n  bundlerUrl?: string;\n  entrypointAddress?: string;\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\nexport type SmartWalletConnectionOptions = {\n  personalAccount: Account;\n  client: ThirdwebClient;\n  chain?: Chain;\n};\n\nexport type UserOperation = {\n  sender: Address;\n  nonce: bigint;\n  initCode: Hex | Uint8Array;\n  callData: Hex | Uint8Array;\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  paymasterAndData: Hex | Uint8Array;\n  signature: Hex | Uint8Array;\n};\n\nexport type UserOperationHexed = {\n  sender: Address;\n  nonce: Hex;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type PaymasterResult = {\n  paymasterAndData: string;\n  preVerificationGas?: bigint;\n  verificationGasLimit?: bigint;\n  callGasLimit?: bigint;\n};\n\nexport type EstimationResult = {\n  preVerificationGas: bigint;\n  verificationGas: bigint;\n  verificationGasLimit: bigint;\n  callGasLimit: bigint;\n};\n\nexport type GasPriceResult = {\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n};\n\nexport type PmTransactionData = {\n  paymaster: Address;\n  paymasterInput: Hex;\n};\n\nexport type UserOperationReceipt = {\n  receipt: TransactionReceipt;\n  logs: TransactionReceipt[\"logs\"];\n  userOpHash: Hex;\n  entryPoint: Address;\n  sender: Address;\n  nonce: bigint;\n  paymaster: Address;\n  actualGasUsed: bigint;\n  actualGasCost: bigint;\n  success: boolean;\n};\n\nexport function formatUserOperationReceipt(\n  userOpReceiptRaw: UserOperationReceipt,\n) {\n  const { receipt: transactionReceipt } = userOpReceiptRaw;\n\n  const receipt = {\n    ...transactionReceipt,\n    transactionHash: transactionReceipt.transactionHash,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex,\n    status: transactionReceipt.status,\n    type: transactionReceipt.type,\n  } as TransactionReceipt;\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n\n  const userOpReceipt = {\n    ...userOpReceiptRaw,\n    receipt,\n    userOpHash: userOpReceiptRaw.userOpHash,\n    actualGasCost: BigInt(userOpReceiptRaw.actualGasCost),\n    actualGasUsed: BigInt(userOpReceiptRaw.actualGasUsed),\n    nonce: BigInt(userOpReceiptRaw.nonce),\n  } as UserOperationReceipt;\n  return userOpReceipt;\n}\n","import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    logs,\n    abi: events.map((e) => e.abiEvent),\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n","import type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const extraData = stringToHex(accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, extraData],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract);\n  }\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, stringToHex(accountSalt ?? \"\")],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getNonce\" function.\n */\nexport type GetNonceParams = {\n  sender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"sender\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"uint192\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x35567e1a\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"sender\",\n  },\n  {\n    type: \"uint192\",\n    name: \"key\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n    name: \"nonce\",\n  },\n] as const;\n\n/**\n * Checks if the `getNonce` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `getNonce` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetNonceSupported } from \"thirdweb/extensions/erc4337\";\n *\n * const supported = await isGetNonceSupported(contract);\n * ```\n */\nexport async function isGetNonceSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getNonce\" function.\n * @param options - The options for the getNonce function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonceParams } \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonceParams({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonceParams(options: GetNonceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.sender, options.key]);\n}\n\n/**\n * Encodes the \"getNonce\" function into a Hex string with its parameters.\n * @param options - The options for the getNonce function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonce } \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonce({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonce(options: GetNonceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetNonceParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getNonce function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetNonceResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetNonceResult(\"...\");\n * ```\n */\nexport function decodeGetNonceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getNonce\" function on the contract.\n * @param options - The options for the getNonce function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getNonce } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getNonce({\n *  contract,\n *  sender: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function getNonce(\n  options: BaseTransactionOptions<GetNonceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.sender, options.key],\n  });\n}\n","import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport type { PaymasterResult, UserOperation } from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultPaymasterUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Get paymaster and data details for a user operation.\n * @param args - The userOp and options\n * @returns - The paymaster and data details for the user operation.\n * @example\n * ```ts\n * import { getPaymasterAndData } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const paymasterAndData = await getPaymasterAndData({\n *  userOp,\n *  client,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperation;\n  client: ThirdwebClient;\n  chain: Chain;\n  entrypointAddress?: string;\n  paymasterOverride?: (userOp: UserOperation) => Promise<PaymasterResult>;\n}): Promise<PaymasterResult> {\n  const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;\n\n  if (paymasterOverride) {\n    return paymasterOverride(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const paymasterUrl = getDefaultPaymasterUrl(chain);\n  const entrypoint = entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n","import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport type {\n  BundlerOptions,\n  SmartWalletOptions,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  estimateUserOpGas,\n  getUserOpGasFees,\n  getUserOpReceipt,\n} from \"./bundler.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\n\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n    timeoutMs?: number;\n    intervalMs?: number;\n  },\n): Promise<TransactionReceipt> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args: {\n  transaction: PreparedTransaction;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n}): Promise<UserOperation> {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n  const isDeployed = await isContractDeployed(accountContract);\n  const initCode = isDeployed\n    ? \"0x\"\n    : await getAccountInitCode({\n        factoryContract: factoryContract,\n        adminAddress,\n        accountSalt: overrides?.accountSalt,\n        createAccountOverride: overrides?.createAccount,\n      });\n  const callData = await encode(executeTx);\n  const bundlerOptions = {\n    client,\n    chain,\n    entrypointAddress: overrides?.entrypointAddress,\n  };\n\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n  const bundlerUrl = overrides?.bundlerUrl ?? getDefaultBundlerUrl(chain);\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n\n  const nonce = await getAccountNonce({\n    accountContract,\n    chain,\n    client,\n    entrypointAddress: overrides?.entrypointAddress,\n    getNonceOverride: overrides?.getAccountNonce,\n  });\n\n  const partialOp: UserOperation = {\n    sender: accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    });\n    const paymasterAndData = paymasterResult.paymasterAndData;\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster,\n        });\n        if (\n          paymasterResult2.paymasterAndData &&\n          paymasterResult2.paymasterAndData !== \"0x\"\n        ) {\n          partialOp.paymasterAndData = paymasterResult2.paymasterAndData as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\",\n  };\n}\n\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args: {\n  userOp: UserOperation;\n  chain: Chain;\n  entrypointAddress?: string;\n  adminAccount: Account;\n}): Promise<UserOperation> {\n  const { userOp, chain, entrypointAddress, adminAccount } = args;\n  const userOpHash = getUserOpHash({\n    userOp,\n    entryPoint: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n    chainId: chain.id,\n  });\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): Promise<Hex> {\n  const { factoryContract, adminAddress, accountSalt, createAccountOverride } =\n    options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\nasync function getAccountNonce(options: {\n  accountContract: ThirdwebContract;\n  chain: Chain;\n  client: ThirdwebClient;\n  entrypointAddress?: string;\n  getNonceOverride?: (accountContract: ThirdwebContract) => Promise<bigint>;\n}) {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride,\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client,\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address,\n  });\n}\n\n/**\n * Get the hash of a user operation.\n * @param args - The user operation, entrypoint address, and chain ID\n * @returns - The hash of the user operation\n * @walletUtils\n */\nfunction getUserOpHash(args: {\n  userOp: UserOperation;\n  entryPoint: string;\n  chainId: number;\n}): Hex {\n  const { userOp, entryPoint, chainId } = args;\n  const hashedInitCode = keccak256(userOp.initCode);\n  const hashedCallData = keccak256(userOp.callData);\n  const hashedPaymasterAndData = keccak256(userOp.paymasterAndData);\n\n  const packedUserOp = encodeAbiParameters(\n    [\n      { type: \"address\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n      { type: \"bytes32\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n    ],\n    [\n      userOp.sender,\n      userOp.nonce,\n      hashedInitCode,\n      hashedCallData,\n      userOp.callGasLimit,\n      userOp.verificationGasLimit,\n      userOp.preVerificationGas,\n      userOp.maxFeePerGas,\n      userOp.maxPriorityFeePerGas,\n      hashedPaymasterAndData,\n    ],\n  );\n  const encoded = encodeAbiParameters(\n    [{ type: \"bytes32\" }, { type: \"address\" }, { type: \"uint256\" }],\n    [keccak256(packedUserOp), entryPoint, BigInt(chainId)],\n  );\n  return keccak256(encoded);\n}\n","import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n  maxUint96,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { concatHex } from \"../../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { DEFAULT_ACCOUNT_FACTORY } from \"./lib/constants.js\";\nimport {\n  createUnsignedUserOp,\n  signUserOp,\n  waitForUserOpReceipt,\n} from \"./lib/userop.js\";\nimport { isNativeAAChain } from \"./lib/utils.js\";\nimport type {\n  PaymasterResult,\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n  UserOperation,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nexport const personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const factoryAddress = options.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY;\n  const chain = connectChain ?? options.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (isNativeAAChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: personalAccount.address,\n    predictAddressOverride: options.overrides?.predictAddress,\n    accountSalt: options.overrides?.accountSalt,\n    accountAddress: options.overrides?.accountAddress,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}. Are you on the right chain?`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account: Account = {\n    address: getAddress(accountContract.address),\n    async sendTransaction(transaction: SendTransactionOption) {\n      // if erc20 paymaster - check allowance and approve if needed\n      const erc20Paymaster = options.overrides?.erc20Paymaster;\n      let paymasterOverride:\n        | undefined\n        | ((userOp: UserOperation) => Promise<PaymasterResult>) = undefined;\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options,\n        });\n        const paymasterCallback = async (): Promise<PaymasterResult> => {\n          return {\n            paymasterAndData: concatHex([\n              erc20Paymaster.address as Hex,\n              erc20Paymaster?.token as Hex,\n            ]),\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      }\n      const executeTx = prepareExecute({\n        accountContract,\n        transaction,\n        executeOverride: options.overrides?.execute,\n      });\n      return _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride,\n          },\n        },\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        transactions,\n        executeBatchOverride: options.overrides?.executeBatch,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n  };\n  return account;\n}\n\nasync function approveERC20(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  erc20Paymaster: {\n    address: string;\n    token: string;\n  };\n}) {\n  const { accountContract, erc20Paymaster, options } = args;\n  const tokenAddress = erc20Paymaster.token;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client,\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.address,\n  });\n\n  if (accountAllowance > 0n) {\n    return;\n  }\n\n  const approveTx = approve({\n    contract: tokenContract,\n    spender: erc20Paymaster.address,\n    amountWei: maxUint96 - 1n,\n  });\n  const transaction = await toSerializableTransaction({\n    transaction: approveTx,\n    from: accountContract.address,\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    transaction,\n    executeOverride: options.overrides?.execute,\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        erc20Paymaster: undefined,\n      },\n    },\n  });\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            chain,\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          chain,\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract: options.factoryContract,\n    accountContract: options.accountContract,\n    adminAddress: options.personalAccount.address,\n    sponsorGas: options.sponsorGas,\n    overrides: options.overrides,\n  });\n  const signedUserOp = await signUserOp({\n    chain: options.chain,\n    adminAccount: options.personalAccount,\n    entrypointAddress: options.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  const userOpHash = await bundleUserOp({\n    options,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    ...options,\n    userOpHash,\n  });\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\ntype HashStructErrorType = EncodeDataErrorType | Keccak256ErrorType | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n"],"names":["concatHex","values","concat","reduce","acc","x","replace","maxUint96","FN_SELECTOR","FN_INPUTS","type","name","FN_OUTPUTS","toBigInt","value","includes","Number","isInteger","Error","Uint8Array","BigInt","uint8ArrayToHex","gasPerPubdataDefault","getEip712Domain","transaction","message","gas","nonce","to","from","maxFeePerGas","maxPriorityFeePerGas","paymaster","paymasterInput","gasPerPubdata","data","txType","gasLimit","gasPerPubdataByteLimit","factoryDeps","transactionToMessage","domain","version","chainId","types","Transaction","primaryType","async","signEip712Transaction","options","account","eip712Transaction","eip712Domain","customSignature","signTypedData","serializedTransaction","toHex","toRlp","serializeTransactionEIP712","populateEip712Transaction","Promise","all","encode","resolvePromisedValue","eip712","then","rpc","getRpcClient","result","method","params","address","numberToHex","undefined","gas_limit","max_fee_per_gas","max_priority_fee_per_gas","gas_per_pubdata_limit","toSerializableTransaction","toEventSelector","toSignatureHash","docsPath","decodeTopic","_ref","param","match","decodeAbiParameters","getAbiItem","parameters","abi","args","isSelector","isHex","strict","abiItems","filter","abiItem","toFunctionSelector","length","matchedAbiItem","inputs","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AbiItemAmbiguityError","argType","abiParameterType","isAddress","Object","components","component","test","Array","isArray","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","parseEventLogs","logs","eventName","map","log","topics","event","strict_","signature","argTopics","AbiEventSignatureEmptyTopicsError","find","formatAbiItem","AbiEventSignatureNotFoundError","isUnnamed","some","indexedInputs","indexed","i","topic","DecodeLogTopicsMismatch","nonIndexedInputs","decodedData","err","AbiDecodingDataSizeTooSmallError","PositionOutOfBoundsError","DecodeLogDataMismatch","size","decodeEventLog","matchArgs","isEqual","input","a","b","InvalidAddressError","toLowerCase","isAddressEqual","keccak256","toBytes","entries","key","includesArgs","_err$abiItem$inputs","Boolean","FilterTypeNotSupportedError","BaseError","constructor","super","encodeEventTopics","item","AbiEventNotFoundError","definition","_abiItem$inputs","_indexedInputs$map","args_","_indexedInputs$map2","_","j","encodeArg","encodeAbiParameters","userOperationRevertReasonEvent","resolvedSignature","parseAbiItem","abiEvent","hash","toEventHash","filters","prepareEvent","arguments","generateRandomUint192","rand1","Math","floor","random","rand2","rand3","rand4","rand5","rand6","hexlifyUserOp","userOp","fromEntries","val","estimateUserOpGas","_args$options$entrypo2","res","sendBundlerRequest","operation","entrypointAddress","ENTRYPOINT_ADDRESS_v0_6","preVerificationGas","hexToBigInt","verificationGas","verificationGasLimit","callGasLimit","MANAGED_ACCOUNT_GAS_BUFFER","getUserOpReceipt","userOpHash","userOpReceiptRaw","receipt","transactionReceipt","transactionHash","blockNumber","contractAddress","cumulativeGasUsed","effectiveGasPrice","gasUsed","transactionIndex","status","blobGasPrice","blobGasUsed","actualGasCost","actualGasUsed","formatUserOperationReceipt","getUserOpReceiptRaw","success","_logs$","revertReason","events","viem_parseEventLogs","e","revertMsg","decodeErrorResult","join","_options$bundlerUrl","DEBUG","console","debug","bundlerUrl","getDefaultBundlerUrl","chain","fetchWithHeaders","getClientFetch","client","response","headers","body","stringify","jsonrpc","id","json","ok","error","statusText","JSON","code","prepareExecute","accountContract","executeOverride","execute","prepareContractCall","contract","getPaymasterAndData","_res$error","paymasterOverride","paymasterUrl","getDefaultPaymasterUrl","entrypoint","paymasterAndData","createUnsignedUserOp","_overrides$bundlerUrl","executeTx","factoryContract","adminAddress","overrides","sponsorGas","initCode","isContractDeployed","accountSalt","createAccountOverride","deployTx","createAccount","stringToHex","prepareCreateAccount","getAccountInitCode","callData","bundlerOptions","isThirdwebUrl","bundlerGasPrice","getUserOpGasFees","resolvedMaxFeePerGas","resolvedMaxPriorityFeePerGas","_ref2","feeData","getDefaultGasOverrides","getNonceOverride","readContract","sender","getNonce","getContract","getAccountNonce","partialOp","DUMMY_SIGNATURE","paymasterResult","estimates","paymasterResult2","signUserOp","adminAccount","entryPoint","hashedInitCode","hashedCallData","hashedPaymasterAndData","packedUserOp","encoded","getUserOpHash","signMessage","raw","hexToBytes","isSmartWallet","wallet","personalAccountToSmartAccountMap","WeakMap","smartWalletToPersonalAccountMap","connectSmartWallet","connectionOptions","creationOptions","_options$factoryAddre","_options$overrides","_options$overrides2","_options$overrides3","personalAccount","connectChain","factoryAddress","DEFAULT_ACCOUNT_FACTORY","gasless","isNativeAAChain","createZkSyncAccount","accountAddress","predictAddressOverride","predictAddress","extraData","catch","cause","getAddress","sendTransaction","_options$overrides4","_options$overrides6","erc20Paymaster","_options$overrides5","_options$overrides8","tokenAddress","token","tokenContract","accountAllowance","owner","spender","allowance","approveTx","approve","amountWei","_sendUserOp","approveERC20","paymasterCallback","sendBatchTransaction","transactions","_options$overrides7","executeBatchOverride","executeBatch","tx","prepareBatchExecute","hashMessage","checkContractWalletSignature","_deployAccount","originalMsgHash","sig","factorySupports712","wrappedMessageHash","verifyingContract","AccountMessage","_typedData","_typedData$domain","_accountContract$addr","typedData","parseTypedData","checkContractWalletSignedTypedData","hashTypedData","onTransactionRequested","_options$personalAcco","_options$personalAcco2","call","createSmartAccount","set","disconnectSmartWallet","get","delete","_transaction$to","_transaction$value","_creationOptions$over3","_creationOptions$over4","prepTx","getCachedChain","serializableTransaction","_creationOptions$over","_creationOptions$over2","pmData","getZkPaymasterData","signedTransaction","txHash","broadcastZkTransaction","_connectionOptions$pe","_connectionOptions$pe2","prepareTransaction","dummyTx","_options$overrides9","unsignedUserOp","signedUserOp","_args$options$entrypo","bundleUserOp","timeout","timeoutMs","interval","intervalMs","endtime","Date","now","userOpReceipt","resolve","setTimeout","waitForUserOpReceipt","bytes","encodable","getEncodable","cursor","createCursor","bytesToHex","list","bodyLength","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","sizeOfBytesLength","pushBytes","getEncodableBytes","EIP712Domain","getTypesForEIP712Domain","validateTypedData","parts","push","hashStruct","hashDomain","encodeData","_ref3","encodedTypes","encodedValues","hashType","field","encodeField","_ref4","encodedHashType","_ref5","unsortedDeps","findTypeDependencies","deps","sort","_ref6","t","encodeType","_ref7","primaryType_","results","Set","has","add","_ref8","prepend","slice","lastIndexOf","parsedType","typeValuePairs","_ref9","_ref10","v"],"sourceRoot":""}