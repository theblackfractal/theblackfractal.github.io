{"version":3,"file":"static/js/86394.d596bb9d.chunk.js","mappings":"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","sources":["../node_modules/viem/errors/request.ts","../node_modules/viem/errors/rpc.ts","../node_modules/thirdweb/src/wallets/wallet-connect/controller.ts"],"sourcesContent":["import { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type HttpRequestErrorType = HttpRequestError & {\n  name: 'HttpRequestError'\n}\nexport class HttpRequestError extends BaseError {\n  body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined\n  headers?: Headers | undefined\n  status?: number | undefined\n  url: string\n\n  constructor({\n    body,\n    cause,\n    details,\n    headers,\n    status,\n    url,\n  }: {\n    body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined\n    cause?: Error | undefined\n    details?: string | undefined\n    headers?: Headers | undefined\n    status?: number | undefined\n    url: string\n  }) {\n    super('HTTP request failed.', {\n      cause,\n      details,\n      metaMessages: [\n        status && `Status: ${status}`,\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n      name: 'HttpRequestError',\n    })\n    this.body = body\n    this.headers = headers\n    this.status = status\n    this.url = url\n  }\n}\n\nexport type WebSocketRequestErrorType = WebSocketRequestError & {\n  name: 'WebSocketRequestError'\n}\nexport class WebSocketRequestError extends BaseError {\n  constructor({\n    body,\n    cause,\n    details,\n    url,\n  }: {\n    body?: { [key: string]: unknown } | undefined\n    cause?: Error | undefined\n    details?: string | undefined\n    url: string\n  }) {\n    super('WebSocket request failed.', {\n      cause,\n      details,\n      metaMessages: [\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n      name: 'WebSocketRequestError',\n    })\n  }\n}\n\nexport type RpcRequestErrorType = RpcRequestError & {\n  name: 'RpcRequestError'\n}\nexport class RpcRequestError extends BaseError {\n  code: number\n\n  constructor({\n    body,\n    error,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    error: { code: number; message: string }\n    url: string\n  }) {\n    super('RPC Request failed.', {\n      cause: error as any,\n      details: error.message,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n      name: 'RpcRequestError',\n    })\n    this.code = error.code\n  }\n}\n\nexport type SocketClosedErrorType = SocketClosedError & {\n  name: 'SocketClosedError'\n}\nexport class SocketClosedError extends BaseError {\n  constructor({\n    url,\n  }: {\n    url?: string | undefined\n  } = {}) {\n    super('The socket has been closed.', {\n      metaMessages: [url && `URL: ${getUrl(url)}`].filter(Boolean) as string[],\n      name: 'SocketClosedError',\n    })\n  }\n}\n\nexport type TimeoutErrorType = TimeoutError & {\n  name: 'TimeoutError'\n}\nexport class TimeoutError extends BaseError {\n  constructor({\n    body,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    url: string\n  }) {\n    super('The request took too long to respond.', {\n      details: 'The request timed out.',\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n      name: 'TimeoutError',\n    })\n  }\n}\n","import type { Prettify } from '../types/utils.js'\nimport { BaseError } from './base.js'\nimport { RpcRequestError } from './request.js'\n\nconst unknownErrorCode = -1\n\nexport type RpcErrorCode =\n  | -1\n  | -32700 // Parse error\n  | -32600 // Invalid request\n  | -32601 // Method not found\n  | -32602 // Invalid params\n  | -32603 // Internal error\n  | -32000 // Invalid input\n  | -32001 // Resource not found\n  | -32002 // Resource unavailable\n  | -32003 // Transaction rejected\n  | -32004 // Method not supported\n  | -32005 // Limit exceeded\n  | -32006 // JSON-RPC version not supported\n  | -32042 // Method not found\n\ntype RpcErrorOptions<code extends number = RpcErrorCode> = {\n  code?: code | (number & {}) | undefined\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n  shortMessage: string\n}\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1474\n */\nexport type RpcErrorType = RpcError & { name: 'RpcError' }\nexport class RpcError<code_ extends number = RpcErrorCode> extends BaseError {\n  code: code_ | (number & {})\n\n  constructor(\n    cause: Error,\n    {\n      code,\n      docsPath,\n      metaMessages,\n      name,\n      shortMessage,\n    }: RpcErrorOptions<code_>,\n  ) {\n    super(shortMessage, {\n      cause,\n      docsPath,\n      metaMessages:\n        metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,\n      name: name || 'RpcError',\n    })\n    this.name = name || cause.name\n    this.code = (\n      cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode\n    ) as code_\n  }\n}\n\nexport type ProviderRpcErrorCode =\n  | 4001 // User Rejected Request\n  | 4100 // Unauthorized\n  | 4200 // Unsupported Method\n  | 4900 // Disconnected\n  | 4901 // Chain Disconnected\n  | 4902 // Chain Not Recognized\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1193\n */\nexport type ProviderRpcErrorType = ProviderRpcError & {\n  name: 'ProviderRpcError'\n}\nexport class ProviderRpcError<\n  T = undefined,\n> extends RpcError<ProviderRpcErrorCode> {\n  data?: T | undefined\n\n  constructor(\n    cause: Error,\n    options: Prettify<\n      RpcErrorOptions<ProviderRpcErrorCode> & {\n        data?: T | undefined\n      }\n    >,\n  ) {\n    super(cause, options)\n\n    this.data = options.data\n  }\n}\n\n/**\n * Subclass for a \"Parse error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ParseRpcErrorType = ParseRpcError & {\n  code: -32700\n  name: 'ParseRpcError'\n}\nexport class ParseRpcError extends RpcError {\n  static code = -32700 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ParseRpcError.code,\n      name: 'ParseRpcError',\n      shortMessage:\n        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Invalid request\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidRequestRpcErrorType = InvalidRequestRpcError & {\n  code: -32600\n  name: 'InvalidRequestRpcError'\n}\nexport class InvalidRequestRpcError extends RpcError {\n  static code = -32600 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidRequestRpcError.code,\n      name: 'InvalidRequestRpcError',\n      shortMessage: 'JSON is not a valid request object.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type MethodNotFoundRpcErrorType = MethodNotFoundRpcError & {\n  code: -32601\n  name: 'MethodNotFoundRpcError'\n}\nexport class MethodNotFoundRpcError extends RpcError {\n  static code = -32601 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: MethodNotFoundRpcError.code,\n      name: 'MethodNotFoundRpcError',\n      shortMessage: `The method${method ? ` \"${method}\"` : ''} does not exist / is not available.`,\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid params\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidParamsRpcErrorType = InvalidParamsRpcError & {\n  code: -32602\n  name: 'InvalidParamsRpcError'\n}\nexport class InvalidParamsRpcError extends RpcError {\n  static code = -32602 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidParamsRpcError.code,\n      name: 'InvalidParamsRpcError',\n      shortMessage: [\n        'Invalid parameters were provided to the RPC method.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for an \"Internal error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InternalRpcErrorType = InternalRpcError & {\n  code: -32603\n  name: 'InternalRpcError'\n}\nexport class InternalRpcError extends RpcError {\n  static code = -32603 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InternalRpcError.code,\n      name: 'InternalRpcError',\n      shortMessage: 'An internal error was received.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid input\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidInputRpcErrorType = InvalidInputRpcError & {\n  code: -32000\n  name: 'InvalidInputRpcError'\n}\nexport class InvalidInputRpcError extends RpcError {\n  static code = -32000 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidInputRpcError.code,\n      name: 'InvalidInputRpcError',\n      shortMessage: [\n        'Missing or invalid parameters.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ResourceNotFoundRpcErrorType = ResourceNotFoundRpcError & {\n  code: -32001\n  name: 'ResourceNotFoundRpcError'\n}\nexport class ResourceNotFoundRpcError extends RpcError {\n  override name = 'ResourceNotFoundRpcError'\n  static code = -32001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceNotFoundRpcError.code,\n      name: 'ResourceNotFoundRpcError',\n      shortMessage: 'Requested resource not found.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource unavailable\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ResourceUnavailableRpcErrorType = ResourceUnavailableRpcError & {\n  code: -32002\n  name: 'ResourceUnavailableRpcError'\n}\nexport class ResourceUnavailableRpcError extends RpcError {\n  static code = -32002 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceUnavailableRpcError.code,\n      name: 'ResourceUnavailableRpcError',\n      shortMessage: 'Requested resource not available.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Transaction rejected\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type TransactionRejectedRpcErrorType = TransactionRejectedRpcError & {\n  code: -32003\n  name: 'TransactionRejectedRpcError'\n}\nexport class TransactionRejectedRpcError extends RpcError {\n  static code = -32003 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: TransactionRejectedRpcError.code,\n      name: 'TransactionRejectedRpcError',\n      shortMessage: 'Transaction creation failed.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type MethodNotSupportedRpcErrorType = MethodNotSupportedRpcError & {\n  code: -32004\n  name: 'MethodNotSupportedRpcError'\n}\nexport class MethodNotSupportedRpcError extends RpcError {\n  static code = -32004 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: MethodNotSupportedRpcError.code,\n      name: 'MethodNotSupportedRpcError',\n      shortMessage: `Method${method ? ` \"${method}\"` : ''} is not implemented.`,\n    })\n  }\n}\n\n/**\n * Subclass for a \"Limit exceeded\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type LimitExceededRpcErrorType = LimitExceededRpcError & {\n  code: -32005\n  name: 'LimitExceededRpcError'\n}\nexport class LimitExceededRpcError extends RpcError {\n  static code = -32005 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: LimitExceededRpcError.code,\n      name: 'LimitExceededRpcError',\n      shortMessage: 'Request exceeds defined limit.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"JSON-RPC version not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type JsonRpcVersionUnsupportedErrorType =\n  JsonRpcVersionUnsupportedError & {\n    code: -32006\n    name: 'JsonRpcVersionUnsupportedError'\n  }\nexport class JsonRpcVersionUnsupportedError extends RpcError {\n  static code = -32006 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: JsonRpcVersionUnsupportedError.code,\n      name: 'JsonRpcVersionUnsupportedError',\n      shortMessage: 'Version of JSON-RPC protocol is not supported.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"User Rejected Request\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UserRejectedRequestErrorType = UserRejectedRequestError & {\n  code: 4001\n  name: 'UserRejectedRequestError'\n}\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static code = 4001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UserRejectedRequestError.code,\n      name: 'UserRejectedRequestError',\n      shortMessage: 'User rejected the request.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unauthorized\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnauthorizedProviderErrorType = UnauthorizedProviderError & {\n  code: 4100\n  name: 'UnauthorizedProviderError'\n}\nexport class UnauthorizedProviderError extends ProviderRpcError {\n  static code = 4100 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnauthorizedProviderError.code,\n      name: 'UnauthorizedProviderError',\n      shortMessage:\n        'The requested method and/or account has not been authorized by the user.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unsupported Method\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnsupportedProviderMethodErrorType =\n  UnsupportedProviderMethodError & {\n    code: 4200\n    name: 'UnsupportedProviderMethodError'\n  }\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n  static code = 4200 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: UnsupportedProviderMethodError.code,\n      name: 'UnsupportedProviderMethodError',\n      shortMessage: `The Provider does not support the requested method${method ? ` \" ${method}\"` : ''}.`,\n    })\n  }\n}\n\n/**\n * Subclass for an \"Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ProviderDisconnectedErrorType = ProviderDisconnectedError & {\n  code: 4900\n  name: 'ProviderDisconnectedError'\n}\nexport class ProviderDisconnectedError extends ProviderRpcError {\n  static code = 4900 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ProviderDisconnectedError.code,\n      name: 'ProviderDisconnectedError',\n      shortMessage: 'The Provider is disconnected from all chains.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Chain Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ChainDisconnectedErrorType = ChainDisconnectedError & {\n  code: 4901\n  name: 'ChainDisconnectedError'\n}\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static code = 4901 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ChainDisconnectedError.code,\n      name: 'ChainDisconnectedError',\n      shortMessage: 'The Provider is not connected to the requested chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Switch Chain\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type SwitchChainErrorType = SwitchChainError & {\n  code: 4902\n  name: 'SwitchChainError'\n}\nexport class SwitchChainError extends ProviderRpcError {\n  static code = 4902 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: SwitchChainError.code,\n      name: 'SwitchChainError',\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an unknown RPC error.\n */\nexport type UnknownRpcErrorType = UnknownRpcError & {\n  name: 'UnknownRpcError'\n}\nexport class UnknownRpcError extends RpcError {\n  constructor(cause: Error) {\n    super(cause, {\n      name: 'UnknownRpcError',\n      shortMessage: 'An unknown RPC error occurred.',\n    })\n  }\n}\n","import type { EthereumProvider } from \"@walletconnect/ethereum-provider\";\nimport type { Address } from \"abitype\";\nimport {\n  type ProviderRpcError,\n  type SignTypedDataParameters,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport {\n  getCachedChain,\n  getChainMetadata,\n  getRpcUrlForChain,\n} from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport {\n  getSavedConnectParamsFromStorage,\n  saveConnectParamsToStorage,\n} from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport type { WCSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nimport type { WCAutoConnectOptions, WCConnectOptions } from \"./types.js\";\n\ntype WCProvider = InstanceType<typeof EthereumProvider>;\n\ntype SavedConnectParams = {\n  optionalChains?: Chain[];\n  chain?: Chain;\n  pairingTopic?: string;\n};\n\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\n\nconst defaultShowQrModal = true;\n\nconst storageKeys = {\n  requestedChains: \"tw.wc.requestedChains\",\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n};\n\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"walletConnect\"> {\n  return wallet.id === \"walletConnect\";\n}\n\n/**\n * @internal\n */\nexport async function connectWC(\n  options: WCConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n\n  let { onDisplayUri } = wcOptions || {};\n\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler && walletId !== \"walletConnect\") {\n    const walletInfo = await getWalletInfo(walletId);\n    const deeplinkHandler = (uri: string) => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        throw new Error(\"No app url found for wallet connect to redirect to.\");\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const { rpcMap, chainsToRequest } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  if (provider.session) {\n    await provider.connect({\n      ...(wcOptions?.pairingTopic\n        ? { pairingTopic: wcOptions?.pairingTopic }\n        : {}),\n      optionalChains: chainsToRequest,\n      chains: chainToRequest\n        ? [chainToRequest.id]\n        : chainsToRequest.length > 0\n          ? [chainsToRequest[0]]\n          : [1],\n      rpcMap: rpcMap,\n    });\n  }\n\n  setRequestedChainsIds(chainsToRequest, storage);\n  // If session exists and chains are authorized, enable provider for required chain\n  const addresses = await provider.enable();\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  if (options) {\n    const savedParams: SavedConnectParams = {\n      optionalChains: options.walletConnect?.optionalChains,\n      chain: options.chain,\n      pairingTopic: options.walletConnect?.pairingTopic,\n    };\n\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n\n  if (wcOptions?.onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", wcOptions.onDisplayUri);\n  }\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(\n  options: WCAutoConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const savedConnectParams: SavedConnectParams | null = storage\n    ? await getSavedConnectParamsFromStorage(storage, walletId)\n    : null;\n\n  const provider = await initProvider(\n    savedConnectParams\n      ? {\n          chain: savedConnectParams.chain,\n          client: options.client,\n          walletConnect: {\n            pairingTopic: savedConnectParams.pairingTopic,\n            optionalChains: savedConnectParams.optionalChains,\n          },\n        }\n      : {\n          client: options.client,\n          walletConnect: {},\n        },\n    walletId,\n    sessionHandler,\n    true, // is auto connect\n  );\n\n  const address = provider.accounts[0];\n\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n// Connection utils -----------------------------------------------------------------------------------------------\n\nasync function initProvider(\n  options: WCConnectOptions,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  sessionRequestHandler?: (uri: string) => void,\n  isAutoConnect = false,\n) {\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await import(\n    \"@walletconnect/ethereum-provider\"\n  );\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const { rpcMap, chainsToRequest } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  const provider = await EthereumProvider.init({\n    showQrModal:\n      wcOptions?.showQrModal === undefined\n        ? sessionRequestHandler\n          ? false\n          : defaultShowQrModal\n        : wcOptions.showQrModal,\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n    optionalMethods: OPTIONAL_METHODS,\n    optionalEvents: OPTIONAL_EVENTS,\n    optionalChains: chainsToRequest,\n    chains: chainToRequest\n      ? [chainToRequest.id]\n      : chainsToRequest.length > 0\n        ? [chainsToRequest[0]]\n        : [1],\n    metadata: {\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      description:\n        wcOptions?.appMetadata?.description ||\n        getDefaultAppMetadata().description,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      icons: [\n        wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      ],\n    },\n    rpcMap: rpcMap,\n    qrModalOptions: wcOptions?.qrModalOptions,\n    disableProviderPing: true,\n  });\n\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n\n  // disconnect the provider if chains are stale when (if not auto connecting)\n  if (!isAutoConnect) {\n    // const isStale = await isChainsStale(provider, chainsToRequest);\n\n    if (provider.session) {\n      await provider.disconnect();\n    }\n  }\n\n  if (walletId !== \"walletConnect\") {\n    function handleSessionRequest() {\n      const walletLinkToOpen =\n        provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n\n      if (sessionRequestHandler && walletLinkToOpen) {\n        sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n\n    provider.signer.client.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.signer.client.off(\"session_request_sent\", handleSessionRequest);\n    });\n  }\n\n  return provider;\n}\n\nfunction createAccount(provider: WCProvider, _address: string) {\n  const address = getAddress(_address);\n  const account: Account = {\n    address: address,\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            from: this.address,\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, this.address],\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const { domain, message, primaryType } =\n        data as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...data.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.address, typedData],\n      });\n    },\n  };\n\n  return account;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: WCProvider,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  storage: AsyncStorage,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount(provider, address);\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount(provider, getAddress(accounts[0]));\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChainWC(provider, newChain, storage),\n  ];\n}\n\n// Storage utils  -----------------------------------------------------------------------------------------------\n\nfunction getNamespaceMethods(provider: WCProvider) {\n  return provider.session?.namespaces[NAMESPACE]?.methods || [];\n}\n\nfunction getNamespaceChainsIds(provider: WCProvider): number[] {\n  const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map(\n    (chain) => Number.parseInt(chain.split(\":\")[1] || \"\"),\n  );\n\n  return chainIds ?? [];\n}\n\nasync function switchChainWC(\n  provider: WCProvider,\n  chain: Chain,\n  storage: AsyncStorage,\n) {\n  const chainId = chain.id;\n  try {\n    const namespaceChains = getNamespaceChainsIds(provider);\n    const namespaceMethods = getNamespaceMethods(provider);\n    const isChainApproved = namespaceChains.includes(chainId);\n\n    if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n      const apiChain = await getChainMetadata(chain);\n\n      const blockExplorerUrls = [\n        ...new Set([\n          ...(chain.blockExplorers?.map((x) => x.url) || []),\n          ...(apiChain.explorers?.map((x) => x.url) || []),\n        ]),\n      ];\n\n      await provider.request({\n        method: ADD_ETH_CHAIN_METHOD,\n        params: [\n          {\n            chainId: numberToHex(apiChain.chainId),\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no clientId on purpose\n            blockExplorerUrls:\n              blockExplorerUrls.length > 0 ? blockExplorerUrls : undefined,\n          },\n        ],\n      });\n      const requestedChains = await getRequestedChainsIds(storage);\n      requestedChains.push(chainId);\n      setRequestedChainsIds(requestedChains, storage);\n    }\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: numberToHex(chainId) }],\n    });\n  } catch (error) {\n    const message =\n      typeof error === \"string\" ? error : (error as ProviderRpcError)?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error as Error);\n    }\n\n    throw new SwitchChainError(error as Error);\n  }\n}\n\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(chains: number[], storage: AsyncStorage) {\n  storage?.setItem(storageKeys.requestedChains, JSON.stringify(chains));\n}\n\n/**\n * Get the last requested chains from the storage.\n * @internal\n */\nasync function getRequestedChainsIds(storage: AsyncStorage): Promise<number[]> {\n  const data = await storage.getItem(storageKeys.requestedChains);\n  return data ? JSON.parse(data) : [];\n}\n\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\nfunction getChainsToRequest(options: {\n  chain?: Chain;\n  optionalChains?: Chain[];\n  client: ThirdwebClient;\n}) {\n  const rpcMap: Record<number, string> = {};\n\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n  }\n\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client,\n    });\n  }\n\n  const optionalChainIds = optionalChains.map((c) => c.id) || [];\n\n  const chainsToRequest: ArrayOneOrMore<number> = options.chain\n    ? [options.chain.id, ...optionalChainIds]\n    : optionalChainIds.length > 0\n      ? (optionalChainIds as ArrayOneOrMore<number>)\n      : [1];\n\n  if (!options.chain && optionalChains.length === 0) {\n    rpcMap[1] = getCachedChain(1).rpc;\n  }\n\n  return {\n    rpcMap,\n    chainsToRequest,\n  };\n}\n\nconst chainsToRequestForSafe = [\n  1, // Ethereum Mainnet\n  11155111, // Sepolia Testnet\n  42161, // Arbitrum One Mainnet\n  43114, // Avalanche Mainnet\n  8453, // Base Mainnet\n  1313161554, // Aurora Mainnet\n  84532, // Base Sepolia Testnet\n  56, // Binance Smart Chain Mainnet\n  42220, // Celo Mainnet\n  100, // Gnosis Mainnet\n  10, // Optimism Mainnet\n  137, // Polygon Mainnet\n  1101, // Polygon zkEVM Mainnet\n  324, // zkSync Era mainnet\n  534352, // Scroll mainnet\n];\n"],"names":["BaseError","RpcRequestError","constructor","_ref3","body","error","url","super","cause","details","message","metaMessages","concat","stringify","name","Object","defineProperty","this","code","RpcError","_ref","docsPath","shortMessage","ProviderRpcError","options","data","ParseRpcError","InvalidRequestRpcError","MethodNotFoundRpcError","method","arguments","length","undefined","InvalidParamsRpcError","join","InternalRpcError","InvalidInputRpcError","ResourceNotFoundRpcError","ResourceUnavailableRpcError","TransactionRejectedRpcError","MethodNotSupportedRpcError","LimitExceededRpcError","JsonRpcVersionUnsupportedError","UserRejectedRequestError","UnauthorizedProviderError","UnsupportedProviderMethodError","ProviderDisconnectedError","ChainDisconnectedError","SwitchChainError","ADD_ETH_CHAIN_METHOD","defaultShowQrModal","storageKeys","requestedChains","lastUsedChainId","async","connectWC","emitter","walletId","storage","sessionHandler","provider","initProvider","wcOptions","walletConnect","onDisplayUri","walletInfo","getWalletInfo","uri","appUrl","mobile","native","universal","Error","fullUrl","formatWalletConnectUrl","redirect","events","addListener","optionalChains","chainToRequest","chain","chainsToRequestForSafe","map","getCachedChain","includes","rpcMap","chainsToRequest","getChainsToRequest","client","session","connect","pairingTopic","chains","id","setRequestedChainsIds","address","enable","providerChainId","normalizeChainId","chainId","_options$walletConnec","_options$walletConnec2","savedParams","saveConnectParamsToStorage","removeListener","onConnect","autoConnectWC","savedConnectParams","getSavedConnectParamsFromStorage","accounts","sessionRequestHandler","_wcOptions$appMetadat","_wcOptions$appMetadat2","_wcOptions$appMetadat3","_wcOptions$appMetadat4","isAutoConnect","EthereumProvider","OPTIONAL_EVENTS","OPTIONAL_METHODS","init","showQrModal","projectId","DEFAULT_PROJECT_ID","optionalMethods","optionalEvents","metadata","appMetadata","getDefaultAppMetadata","description","icons","logoUrl","qrModalOptions","disableProviderPing","setMaxListeners","Number","POSITIVE_INFINITY","disconnect","handleSessionRequest","_provider$session","walletLinkToOpen","peer","signer","on","off","createAccount","_address","getAddress","sendTransaction","tx","transactionHash","request","params","gas","numberToHex","value","from","to","signMessage","messageToSign","stringToHex","raw","Uint8Array","uint8ArrayToHex","signTypedData","_data","parseTypedData","domain","primaryType","types","EIP712Domain","getTypesForEIP712Domain","validateTypedData","typedData","serializeTypedData","account","onAccountsChanged","onChainChanged","onDisconnect","removeItem","emit","newAccount","newChainId","newChain","setItem","String","namespaceChains","_provider$session3","chainIds","namespaces","NAMESPACE","parseInt","split","getNamespaceChainsIds","namespaceMethods","_provider$session2","methods","getNamespaceMethods","_chain$blockExplorers","_apiChain$explorers","apiChain","getChainMetadata","blockExplorerUrls","Set","blockExplorers","x","explorers","chainName","nativeCurrency","rpcUrls","getValidPublicRPCUrl","getItem","JSON","parse","getRequestedChainsIds","push","test","switchChainWC","getRpcUrlForChain","slice","optionalChainIds","c","rpc"],"sourceRoot":""}